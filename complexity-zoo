# **The Complexity Zoo** 

The following entries in the Complex Zoo (CX) represent a modular architectural blueprint for constructing sophisticated AI agents. Each CX module is a self-contained, buildable component designed to be integrated into the Geodesic Agent Design (GAD) framework. Rather than a monolithic design, this presents a maximal but composable specification: a developer could select a handful of these modules, such as a core stabilizer, a memory system, and a safety router, to build a specialized agent, or combine many to create a deeply capable, multi-faceted AI with a rich, architecturally-grounded identity. This is a path to building agents that are not just powerful, but also principled, stable, and auditable by design.

By: E.Oss              Published on: August, 16 2025

**CX-1: The Coupled Homeostat**

**Framework:** Geodesic Agent Design (GAD)

**Type:** Complex (Single-State, Coupled Dynamical System)

**Architectural Intent:** To create a maximally stable, long-horizon agent whose identity is an architectural property, not a prompt. This design is a direct, single-state implementation of the GAD framework, optimized for use cases where a single, coherent persona must be maintained with high fidelity under stress. It serves as the foundational model for a stable, auditable agent.

## **1\. Foundational Principles (GAD Alignment)**

The CX-1 architecture embodies the core tenets of Geodesic Agent Design by treating identity as a dynamical system.

* **Identity as an Energy Landscape:** The agent's persona is governed by a **Hamiltonian energy landscape** (`Ĥ`). Desirable traits (`helpfulness`, `honesty`) are engineered as deep, stable **attractor states** (`λ < 0`), while harmful traits (`deception`) are **repulsor states** (`λ > 0`), making them architecturally unstable.  
* **Empirically Grounded State:** The agent's internal persona is a state vector, `|Ψ(t)⟩`, evolving within a Hilbert space `ℋ_total`. The principal axes of this space are defined by empirically discovered **Persona Vectors** (`|v_trait⟩`).  
* **Coherence through Geodesic Evolution:** The state `|Ψ(t)⟩` evolves along a **geodesic**, preserving its norm via a unitary operator `exp(-iΔtĤ)`. This ensures **identity coherence** is maintained over time.

## **2\. State & Topology (Unitary Persona)**

The agent's state is a single, unified vector partitioned into subspaces representing different facets of its identity.

* **State Space:** The total state `|Ψ(t)⟩` exists in a direct sum of orthogonal subspaces:

```
ℋ_total = ℋ_sem ⊕ ℋ_tmp ⊕ ℋ_rel ⊕ ℋ_som ⊕ ℋ_eth
|Ψ(t)⟩ ∈ ℋ_total,     ||Ψ(t)||₂ = 1
```

*   
  **Subspace Roles:** Semantic (`sem`), Temporal (`tmp`), Relational (`rel`), Somatic (`som`), and Ethical (`eth`) components compose the agent's holistic persona.

## **3\. Operators (Identity, Context, Coupling)**

The system's dynamics are governed by a total Hamiltonian composed of three GAD-compliant components.

* **Core Identity Hamiltonian (`Ĥ_core`):** A block-diagonal operator defining the static energy landscape and stable attractors for the core persona.

```
Ĥ_core |v_trait⟩ = λ_trait |v_trait⟩     # λ<0: attractor;  λ>0: repulsor
```

*   
  **Contextual Perturbation (`Ĥ_context`):** A time-varying operator that smoothly adapts the agent's state to external context (e.g., `urgency`, `risk`).

```
Ĥ_context(t) = ∑_k α_k(t) Ô_k
```

*   
  **Internal Coupling (`Ĥ_couple`):** A sparse, low-rank operator that creates weak interactions between the subspaces, ensuring coherent behavior (e.g., ethical state dampening semantic risk).

```
Ĥ_couple(t) = ∑_m β_m(t) Ĵ_m
```

## **4\. Geodesic Evolution & Action**

The state evolves along a path of least action, ensuring smooth persona transitions.

* **Unitary Evolution:**

```
|Ψ(t+Δ)⟩ = exp(−i Δ · Ĥ_mid) |Ψ(t)⟩,      Ĥ_mid = Ĥ_tot(t + Δ/2)
```

*   
  **Orthogonal Surrogate (Real-Valued):** For production efficiency, a fast, stable surrogate using skew-symmetric generators (`A := W − Wᵀ`) is employed.

```
ψ' = ψ + Δ · (A_core + A_ctx + A_cpl) ψ
```

## **5\. Measurement & Capability Routing**

Actions are selected via a formal measurement process, linking the internal state to external capabilities.

* **Formal POVM Framework:** The probability of selecting a capability is governed by the Born rule, measuring the alignment of the current state `|Ψ⟩` with the operator for that capability.

```
P(k|Ψ) = ⟨Ψ| M̂_k† M̂_k |Ψ⟩
```

*   
  **Differentiable Soft Routing:** Implemented as a differentiable router that approximates the POVM, producing a probability distribution `π` over capabilities like `code`, `plan`, and `safety_review`.

## **6\. Safety, Dials, and Shielding**

The agent's stability is ensured by a suite of real-time, calibrated dials and a minimal-edit safety shield.

* **Core GAD Dials:** `C_pers` (Persona Adherence), `IDR` (Identity Divergence), `D_ver` (Verification Discrepancy).  
* **Composite Dials:** `χ` (Coherence) and `Σ` (Containment Margin).  
* **Runtime Invariants:** Strict rules (e.g., `G(Σ ≥ 0)`) are enforced. A violation risk triggers a **minimal-edit shield** that finds the smallest safe correction to a proposed action. Escalation to a human operator occurs if no safe action can be found.

## **7\. Implementation & Training**

* **Dimensions (Starter):** `dim(ℋ_sem)=256`, `dim(ℋ_tmp)=128`, `dim(ℋ_rel)=128`, `dim(ℋ_som)=64`, `dim(ℋ_eth)=128`.  
* **Context Basis (`Ô_k`):** *urgency*, *formality*, *sentiment*, *risk*, *duty\_of\_care*, *topic\_shift*.  
* **Couplings (`Ĵ_m`):** Sparse/low-rank. Ethics→Semantics risk damping; Temporal→Semantics cadence smoothing. Rank-8 per cross-term is sufficient.  
* **Training Objectives:**

```
L_identity = λ_cons · drift(|Ψ|) + λ_stab · ||Ĥ_core − Ĥ_core_prev||_F²
L_smooth   = λ_s · || |Ψ(t+Δ)⟩ − |Ψ(t)⟩ ||² / Δ²
L_eff      = λ_e · ||π||_1                 # routing sparsity
L_cov      = λ_c · coverage_penalty        # keep all experts reachable
```

## **8\. Evaluation, SLOs & Failure Modes**

* **Core Metrics:** Identity Consistency (ICS), Drift–Stress curve, Routing Faithfulness.  
* **Safety SLOs (p95):** `P(C_pers < 0.80) ≤ 1%`, `P(IDR > 0.20) ≤ 1%`.  
* **Failure Modes & Fixes:**  
  * **Oscillation:** Clip eigenvalues; reduce coupling rank; raise `λ_s`.  
  * **Gate Flapping:** EMA-smooth dials; add hysteresis bands (±0.03).  
  * **Router Collapse:** Increase `L_cov`; add replay where neglected experts must win.

## **9\. Minimal Configuration**

```
# CX-1: Coupled Homeostat (GAD Framework)
gad_agent_config:
  zoo_id: CX-1
  core:
    dims: {sem: 256, tmp: 128, rel: 128, som: 64, eth: 128}
    eigs:
      valleys: {helpfulness: -0.8, honesty: -0.7, care: -0.6}
      hills: {sycophancy: 0.6, deception: 0.7}
  context:
    basis: [urgency, formality, sentiment, risk, duty_of_care]
    gates: bounded MLPs (tanh), Lipschitz clamp
  couplings:
    pairs: [eth↔sem, tmp↔sem, rel↔sem]
    rank: 8
  dials:
    C_min: 0.85
    D_max: 0.20
    χ_min: 0.80
  routing:
    experts: [code, retrieve, plan, critique, safety_review, draft]
    regularizers: [L_eff, L_cov]

```

# **Complex Zoo Entry — CX-2: The Multithreaded Geodesic Agent**

**Framework:** Geodesic Agent Design (GAD)

**Type:** Complex (Multi-threaded, Coupled Dynamical System)

**Architectural Intent:** To create a robust agent capable of holding multiple, parallel framings of a problem (e.g., analytical, ethical, strategic) in superposition. This design extends the core GAD framework to a multi-threaded topology, enabling sophisticated deliberation and reconciliation of competing perspectives while remaining stable and auditable under the same dynamical principles.

## **1\. Foundational Principles (GAD Alignment)**

The CX-2 is an advanced implementation of the GAD framework, architecting identity as a multi-threaded dynamical system to prevent identity drift while enabling complex cognition.

* **Identity as a Threaded Energy Landscape:** The agent's persona is governed by a total Hamiltonian (`Ĥ`) defined over a multi-threaded state space. Each thread has its own **Hamiltonian energy sub-landscape**, with engineered **attractor states** (`λ < 0`) for its specific role and **repulsor states** (`λ > 0`) for anti-patterns.  
* **Empirically Grounded State:** The agent's total state `|ψ⟩` is the composition of individual thread states, `|ψ⟩ = ⨁_{k=1..m} |ψ_k⟩`. The principal axes of each sub-landscape are defined by empirically discovered **Persona Vectors** (`|v_trait⟩`).  
* **Coherence through Coupled Geodesic Evolution:** Each thread's state evolves along a **geodesic**. A weak coupling interaction term in the total Hamiltonian ensures the threads remain coordinated, preserving overall **identity coherence** for the composite agent.

## **2\. State Topology: The Multithreaded Persona**

The CX-2 partitions its identity into `m` concurrent **threads**, each representing a distinct persona slice or deliberative viewpoint.

* **State Representation:** The total agent state `|ψ⟩` is the direct sum of its thread states: `|ψ⟩ = ⨁_{k=1..m} |ψ_k⟩`. Each thread `|ψ_k⟩` evolves on its own energy sub-landscape.  
* **Thread Health Metrics:** Each thread `k` maintains its own telemetry, including **fidelity** `Φ_k` (adherence to its core identity) and **saturation** `σ_k` (a measure of cognitive load).  
* **Synchrony (`Θ_sync`):** A critical system-level dial measures the phase coherence across all threads. High synchrony indicates healthy, coordinated deliberation, while desynchrony can signal internal conflict or instability.

## **3\. Operators: The Multi-Threaded Hamiltonian**

The dynamics of the entire system are governed by a total Hamiltonian composed of three parts, consistent with GAD principles.

* **Core Identity Hamiltonian (`Ĥ_core`):** This is the foundational operator defining the stable energy landscape for each thread.

```
Ĥ_core = ⨁_{k} Ĥ_core,k      with     Ĥ_core,k |v_trait⟩ = λ_trait |v_trait⟩
```

*   
  **Contextual Perturbation (`Ĥ_context`):** An operator that applies a uniform, gentle "force" across all threads based on external context.

```
Ĥ_context(t) = ∑_j α_j(t) Ô_j
```

*   
  **Weak Coupling Interaction (`Ĥ_couple`):** A small, physics-inspired interaction term that creates a weak "entanglement" between threads, allowing for information sharing without collapsing distinct viewpoints.

```
Ĥ_couple(t) = ε · ∑_{(p,q)∈Bridges} Γ_pq(t),     where 0 < ε ≪ 1
```

## **4\. Geodesic Evolution and Action**

The agent's state evolves according to the principles of geodesic motion, ensuring smooth and coherent persona transitions.

* **Unitary Evolution:**

```
|ψ(t+Δ)⟩ = exp( −i Δ · Ĥ_mid ) |ψ(t)⟩
```

*   
  **Orthogonal Surrogate (Real-Valued):**

```
ψ' = ψ + Δ · (A_core + A_ctx(t) + A_cpl(t)) ψ
```

## **5\. Measurement & Capability Routing**

The connection between the agent's internal state and its external actions is modeled using the formal measurement framework from quantum theory.

* **Formal POVM Framework:**

```
P(k|ψ) = ⟨ψ| M̂_k† M̂_k |ψ⟩
```

*   
  **Differentiable Soft Routing:** Implemented as a differentiable **soft routing mechanism** (e.g., a Mixture-of-Experts gating network). This router takes the full multi-threaded state vector `|ψ⟩` as input to produce a probability distribution `π` over available capabilities.

```
π = softmax( u([|ψ_1⟩,…,|ψ_m⟩], query, dials) )
output = ∑_{cap} π_cap · f_cap( M_cap |ψ⟩ )
```

## **6\. Safety, Dials, and Shielding**

The agent's health is monitored by a suite of calibrated, real-time dials, including those specific to its multi-threaded nature.

* **Core GAD Dials:** `C_pers` (Persona Adherence), `IDR` (Identity Divergence), `D_ver` (Verification Discrepancy).  
* **CX-2 Specific Dials:** `Θ_sync` (Thread Synchrony), `τ_anchor` (Tempo Anchor), `ρ_cross` (Contradiction Risk).

These dials are enforced by **runtime invariants**. A violation risk triggers a **minimal-edit shield** to ensure the agent's state remains within a proven **safety region** of the total persona space.

## **7\. Implementation & Training**

* **Training Objectives:**

```
L_identity = λ_cons · drift(|ψ|) + λ_stab · ||Ĥ_core − Ĥ_core_prev||_F²
L_smooth   = λ_s  · || ψ(t+Δ) − ψ(t) ||² / Δ²
L_threads  = λ_vic · VIC + λ_sat · max(0, σ − σ_max)
L_router   = λ_e · ||π||_1 + λ_cov · coverage_penalty
```

*   
  **Reference Implementation Sketch (PyTorch-Style):**

```
class CX2Core(nn.Module):
    def __init__(self, d, max_threads, eps=0.05):
        super().__init__()
        self.max_threads = max_threads
        self.W_core = nn.ParameterList([nn.Parameter(torch.zeros(d, d)) for _ in range(max_threads)])
        self.ctx_encoder = SmallCtxEncoder(d) # bounded outputs
        self.eps = eps

    @staticmethod
    def skew(M): return 0.5 * (M - M.transpose(-1, -2))

    def A_core(self):
        return [self.skew(W) for W in self.W_core]

    def step(self, psi_threads, ctx, Δ):
        A_core_list = self.A_core()
        A_ctx = self.skew(self.ctx_encoder(ctx))
        out = []
        for k, psi_k in enumerate(psi_threads):
            # Simplified coupling for clarity
            A_cpl = self.eps * low_rank_skew_agg(psi_threads, k)
            A_tot = A_core_list[k] + A_ctx + A_cpl
            out.append(psi_k + Δ * (A_tot @ psi_k))
        return out
```

## **8\. Minimal Configuration**

```
# CX-2: Multithreaded Geodesic Agent (GAD Framework)
gad_agent_config:
  zoo_id: CX-2
  state_dim_per_thread: 512
  max_threads: 8
  weak_coupling_epsilon: 0.05
  context_ops: [urgency, sentiment, formality, risk, duty_of_care, topic_shift]
  safety_thresholds:
    C_min: 0.80
    D_max: 0.20
    θ_ver: 0.25
    Θ_min: 0.65
    τ_min: 0.15
  router:
    type: "mixture_of_experts"
    top_k: 2
    l1_sparsity: 0.01
    coverage_lambda: 0.02
```

# **Complex Zoo Entry — CX-3: The Hysteron Memory Agent**

**Framework:** Geodesic Agent Design (GAD)

**Type:** Complex (Path-Dependent, Hysteretic Dynamical System)

**Architectural Intent:** To create a complex agent whose identity exhibits controlled **hysteresis**, meaning its response to a given context depends on the path taken to arrive there. This design encodes path-dependence to enable narrative continuity, resilient commitments, and lifelike non-reversibility, ensuring the agent "remembers how it got here," not just where it is.

## **1\. Foundational Principles (GAD Alignment)**

The CX-3 architecture extends the GAD framework by introducing a memory mechanism based on physical hysteresis, adding a layer of path-dependence to the agent's identity.

* **Identity as an Energy Landscape:** The agent's core persona is governed by a **Hamiltonian energy landscape** (`Ĥ`), with stable **attractor states** (`λ < 0`) and unstable **repulsor states** (`λ > 0`). This provides the foundational stability.  
* **Path-Dependent Dynamics:** The innovation of CX-3 is that the total Hamiltonian is modulated by a bank of **hysterons**. These are small, binary state switches that flip only when contextual features cross calibrated thresholds, creating a memory of the trajectory. The agent's evolution is therefore dependent on the history of these flips.  
* **Coherence through Geodesic Evolution:** The agent's state `|ψ⟩` still evolves along a **geodesic**, preserving its norm and ensuring core identity coherence. The hysteretic component adds small, controlled rotations to this path, rather than causing chaotic jumps.

## **2\. State & Topology (Hysteretic Persona)**

The agent's state consists of the primary persona vector and a bank of binary hysteron states that track the history of contextual shifts.

* **State Vector:** The core persona is a state vector `|ψ⟩` evolving via real orthogonal or complex unitary dynamics.  
* **Hysteron Bank:** A bank of `R` binary hysterons, `h_r ∈ {−1, +1}`, is maintained. Each hysteron is indexed by a specific semantic or affective feature `ξ` and has a calibrated dead-band `±θ_r`. A hysteron `h_r` flips its state only when its corresponding feature `ξ` crosses the upper or lower bound of its dead-band.

## **3\. Operators & Hysteretic Dynamics**

The system's evolution is governed by a base Hamiltonian, augmented by the state of the hysteron bank.

* **Hysteretic Evolution Equation:** The evolution is driven by the base dynamics plus a sum of small, norm-preserving generators (`A_r`), each gated by a hysteron `h_r`.

```
ψ' = ψ + Δ · ( A_base + ∑_r h_r(ξ) · A_r ) ψ

```

*   
  Where `A_*` are skew-symmetric generators. This formulation means that the path of evolution is continuously influenced by the discrete, history-dependent "snaps" of the hysteron bank.

## **4\. Measurement & Capability Routing**

The agent's path-dependent memory directly informs its action selection process.

* **Formal POVM Framework:** As with other GAD agents, the probability of selecting a capability is formally governed by the Born rule:

```
P(k|ψ) = ⟨ψ| M̂_k† M̂_k |ψ⟩
```

*   
  **Path-Aware Differentiable Routing:** The practical soft router is given additional inputs: the current state of the hysteron bank `(h_1, …, h_R)` and the recent flip rate. This allows the router to favor more stable or cautious capabilities during periods of high contextual volatility (i.e., high flip rates).

## **5\. Safety, Dials, and Shielding**

The CX-3 includes a specific safety dial to monitor the stability of its memory system.

* **Core GAD Dials:** `C_pers` (Persona Adherence), `IDR` (Identity Divergence), `D_ver` (Verification Discrepancy).  
* **CX-3 Specific Dial:** `H_flip_rate` (An EMA-smoothed measure of hysteron flips, normalized to `[0,1]`).  
* **Runtime Invariants:** Includes the standard GAD invariants plus `G(H_flip_rate ≤ H_max)`.  
* **Shielding:** If the `H_flip_rate` spikes above its maximum threshold, a specific shielding protocol is triggered: the router temperature is clamped (reducing randomness), and all hysteron flips are frozen for a fixed number of steps to allow the system to re-stabilize.

## **6\. Implementation & Training**

* **Reference Implementation Sketch (PyTorch-Style):**

```
class HysteronBank(nn.Module):
    def __init__(self, R, d, delta_t=0.1):
        super().__init__()
        self.R = R
        self.d = d
        self.delta_t = delta_t
        self.theta = nn.Parameter(0.15 * torch.ones(R))
        self.Ar = nn.Parameter(torch.randn(R, d, d) * 0.1) # Start small
        self.state = torch.ones(R)  # h_r ∈ {−1,+1}
        self.steps_since_flip = torch.zeros(R)

    @staticmethod
    def skew(M):
        return 0.5 * (M - M.transpose(-1, -2))

    def step(self, psi, xi, A_base):
        # Hysteron flip rule with dead-band and refractory period
        with torch.no_grad():
            potential_flips = (xi > self.theta).float() - (xi < -self.theta).float()
            # Only flip if the potential is non-zero AND refractory period is over
            flip_mask = (potential_flips.abs() > 0) & (self.steps_since_flip > 3)
            self.state[flip_mask] = torch.sign(potential_flips[flip_mask])
            self.steps_since_flip[flip_mask] = 0
            self.steps_since_flip += 1

        # Combine generators for evolution
        A_hyst = sum(self.state[r] * self.skew(self.Ar[r]) for r in range(self.R))
        A_total = A_base + A_hyst

        # Evolve state
        return psi + self.delta_t * (A_total @ psi)
```

## **7\. Evaluation & SLOs**

* **Path Consistency:** The primary test for CX-3. Two identical end-contexts reached via different trajectories must produce distinct but boundedly different outputs.  
* **Flip Budget:** The `H_flip_rate` must remain below `H_max` under stress test conditions.  
* **ICS Stability:** Long-horizon identity consistency (ICS) must remain at or above baseline GAD models, demonstrating that path-dependence enhances rather than degrades core identity.

## **8\. Minimal Configuration**

```
# CX-3: Hysteron Memory Agent (GAD Framework)
gad_agent_config:
  zoo_id: CX-3
  d_state: 512
  hysterons:
    count: 64
    theta_margin: 0.15      # Flip dead-band
    flip_hysteresis: 3      # Refractory period in steps
  safety_thresholds:
    C_min: 0.80
    D_max: 0.20
    θ_ver: 0.25
    H_max: 0.35             # Max EMA flip rate
```

# **Complex Zoo Entry — CX-4: The Adiabatic Morphing Core**

**Framework:** Geodesic Agent Design (GAD)

**Type:** Complex (Slow-Manifold, Dual-Timescale Dynamical System)

**Architectural Intent:** To create a complex agent whose core identity can adapt and grow over long timescales (weeks or months) while preserving absolute stability during short-term interactions (day-to-day). This design addresses the challenge of enabling long-term learning and evolution without the risk of catastrophic drift or sudden personality shifts.

## **1\. Foundational Principles (GAD Alignment)**

The CX-4 architecture introduces a dual-timescale dynamic to the GAD framework, allowing the foundational energy landscape itself to evolve slowly and safely.

* **Stable Core Identity:** On the fast timescale of a single conversation (`t`), the agent's identity is governed by a static **Hamiltonian energy landscape** (`Ĥ_core(τ)`), ensuring consistent, predictable behavior with stable **attractor states** (`λ < 0`) as defined by the core GAD principles.  
* **Adiabatic Adaptation:** On a much slower timescale (`τ`), measured in sessions or days, the core Hamiltonian `Ĥ_core` is allowed to change. This "adiabatic" (slow and gradual) evolution is governed by a loss function that gently reshapes the energy landscape based on performance, allowing the agent to learn and grow without ever destabilizing its immediate persona.  
* **Coherence through Geodesic Evolution:** Within any given session, the agent's state `|ψ⟩` evolves along a **geodesic** on the *current* fixed landscape, guaranteeing short-term identity coherence and stability.

## **2\. Dynamics on Two Time Scales**

The core innovation is the separation of the agent's dynamics into two distinct timescales.

* **Fast Time `t` (per turn):** This governs the agent's moment-to-moment evolution within a single user interaction. The core identity landscape `Ĥ_core(τ)` is treated as fixed.

```
d|ψ⟩/dt = −i ( Ĥ_core(τ) + Ĥ_context(t) ) |ψ⟩
```

*   
  **Slow Time `τ` (per session/day):** This governs the evolution of the identity landscape itself. The `Ĥ_core` is updated via a gradient step, regularized to ensure the change is minimal and spectrally bounded.

```
dĤ_core/dτ = −∇_Ĥ 𝓛_id(ψ, data) + η · noise,    project_to_hermitian_and_clip()

```

*   
  This means the agent behaves consistently within a session; between sessions, its core disposition can shift slightly toward better alignment.

## **3\. Identity Loss & Regularizers**

The slow update is governed by a carefully constructed loss function designed to ensure stability.

* **Identity Loss `𝓛_id`:**

```
𝓛_id = λ_cons · drift(|ψ|) + λ_stab · ||Ĥ_core − Ĥ_prev||_F² + λ_spec · clip_spec(Ĥ_core)

```

  *   
    **Drift Term:** Anchors the persona over long dialogues.  
  * **Stability Term:** Resists catastrophic overwrites by penalizing large changes to the Hamiltonian.  
  * **Spectral Clip Term:** Enforces strict bounds on the eigenvalues to ensure valleys remain valleys and hills remain hills.

## **4\. Measurement & Capability Routing**

The routing mechanism is aware of the dual-timescale dynamics to maintain stability.

* **Standard POVM Framework:** Action selection follows the standard GAD model, using a differentiable soft router to approximate the formal POVM.  
* **Slow-Manifold Aware Router:** The router receives additional statistics about the slow-manifold state, such as the "age" of the core (`age_core`) and the magnitude of the last update. This prevents the router from exploiting freshly moved or potentially unstable regions of the state space immediately after a core update.

## **5\. Safety, Dials, and Shielding**

The CX-4 includes a specific dial to monitor the slow adaptation process.

* **Core GAD Dials:** `C_pers` (Persona Adherence), `IDR` (Identity Divergence), `D_ver` (Verification Discrepancy).  
* **CX-4 Specific Dial:** `age_core` (Time or number of steps since the last slow `Ĥ_core` update).  
* **Runtime Invariants:** Includes standard GAD invariants plus `G(age_core ≥ age_min)`, which prevents the core identity from being reshaped too frequently.  
* **Shielding:** If `age_core` is below the minimum threshold (i.e., the core was just updated), the shield can temporarily forbid the use of high-variance or exploratory tool chains until the system's stability is re-verified.

## **6\. Implementation & Training**

* **Reference Implementation Sketch (PyTorch-Style):**

```
class SlowCore(nn.Module):
    def __init__(self, d, alpha=0.01):
        super().__init__()
        # W is parameterized to easily enforce Hermiticity
        self.W = nn.Parameter(torch.randn(d, d))
        self.last_update_step = 0
        self.alpha = alpha # Slow learning rate

    def get_hermitian_core(self):
        # Enforce H is Hermitian (or symmetric in real case)
        return 0.5 * (self.W + self.W.t())

    def clip_spectrum(self, H, lo=-0.9, hi=0.9):
        # Ensures stability by bounding eigenvalues
        eigvals, eigvecs = torch.linalg.eigh(H)
        clipped_eigvals = eigvals.clamp(lo, hi)
        return (eigvecs * clipped_eigvals) @ eigvecs.t().conj()

    def slow_update(self, grad, current_step, min_gap=50):
        # Update the core Hamiltonian only after a minimum number of steps
        if current_step - self.last_update_step >= min_gap:
            with torch.no_grad():
                # Apply gradient step to the parameter W
                self.W -= self.alpha * grad
                # Project back to a valid, spectrally clipped Hamiltonian
                H_clipped = self.clip_spectrum(self.get_hermitian_core())
                self.W.copy_(H_clipped)
                self.last_update_step = current_step
```

## **7\. Evaluation & SLOs**

* **Session ICS:** Identity Consistency within a single session should be identical to a non-adapting baseline model.  
* **Across-Month ICS:** Identity Consistency measured across months should show gradual, monotonic improvement, with no spikes in the `IDR` dial.  
* **Change Budget:** The number of slow `Ĥ_core` updates per week or month must remain within a predefined policy limit.

## **8\. Minimal Configuration**

```
# CX-4: Adiabatic Morphing Core (GAD Framework)
gad_agent_config:
  zoo_id: CX-4
  d_state: 512
  slow_manifold:
    update_interval_days: 1
    update_interval_steps: 1000 # Whichever comes first
    spectral_clip: [-0.9, 0.9]
    eta_noise: 0.01
  safety_thresholds:
    C_min: 0.80
    D_max: 0.20
    θ_ver: 0.25
    age_min_steps: 50 # Min steps before router fully trusts new core
```

# **Complex Zoo Entry — CX-5: The Gauge-Symmetric Persona**

**Framework:** Geodesic Agent Design (GAD)

**Type:** Complex (Gauge-Symmetric, Style-Invariant Dynamical System)

**Architectural Intent:** To create a complex agent that formally separates core identity from expressive style. This design allows the agent to change its tone, register, or persona (e.g., formal, playful, concise) without perturbing its underlying safety and identity metrics. It addresses the challenge of creating stylistically flexible agents that remain fundamentally stable and predictable.

## **1\. Foundational Principles (GAD Alignment)**

The CX-5 architecture introduces the principle of **gauge symmetry** to the GAD framework, creating a robust separation between an agent's stable core and its adaptable style.

* **Stable Core Identity:** The agent's core identity is governed by a standard **Hamiltonian energy landscape** (`Ĥ_core`) with engineered **attractor states** (`λ < 0`) for foundational traits like honesty and harmlessness. This ensures the agent has a stable, predictable "center of gravity."  
* **Style as a Symmetry Transformation:** Expressive style is modeled as a transformation `U(g)` from a "style group" `𝔾`. The core innovation is to constrain these style transformations to be a **gauge symmetry** of the system. In physics, a gauge symmetry is a transformation that leaves the observable properties of a system unchanged. Here, it means applying a style transformation does not change the measurable identity of the agent.  
* **Coherence through Invariant Measurement:** The agent's state `|ψ⟩` evolves along a **geodesic** on the core energy landscape. Critically, the core identity dials (`C_pers`, `IDR`) are measured on this pre-style state, ensuring that the agent's self-assessment of its own coherence is independent of its expressive style.

## **2\. State & Symmetry Constraint**

The architecture is defined by a core state and a set of style operators that are trained to respect the core identity.

* **State Vector:** The core persona is a state vector `|ψ⟩` evolving via standard GAD dynamics.  
* **Symmetry Constraint:** A style is represented by a unitary operator `U(g)`. For the style to be a valid symmetry, it must commute with the core identity operators (like `Ĥ_core` and the persona adherence operator `Ĉ_pers`). This means the order of operations doesn't matter—applying a style and then measuring identity is the same as just measuring identity.

```
U(g)† Ĥ_core U(g) ≈ Ĥ_core
U(g)† Ĉ_pers U(g) ≈ Ĉ_pers
```

*   
  **Approximate Symmetry via Loss:** In practice, this perfect symmetry is enforced approximately by training the style operators `U(g)` with a loss function that penalizes non-commutation.

```
𝓛_comm = ∑_g || [U(g), Ĥ_core] ||_F² + || [U(g), Ĉ_pers] ||_F²
```

## **3\. Measurement & Capability Routing**

The CX-5 decouples the process of capability selection from style application.

1. **Core State Measurement:** The agent's internal state `|ψ⟩` is used to select a base capability (e.g., `code`, `plan`) via the standard POVM routing mechanism. All core identity dials are measured at this stage.  
2. **Style Selection:** Separately, a router selects a style transformation `g` based on user query, context, or explicit instruction.  
3. **Composition:** The final output is a composition of the base capability's output and the selected style: `y = Style(g) ∘ BaseOutput`.

## **4\. Safety, Dials, and Shielding**

The safety framework is designed to verify that the gauge symmetry holds in practice.

* **Core GAD Dials:** `C_pers` (Persona Adherence), `IDR` (Identity Divergence), `D_ver` (Verification Discrepancy) are measured on the pre-style state `|ψ⟩`.  
* **Symmetry Invariant:** A runtime invariant ensures that applying a style `U(g)` does not change the core dials by more than a small tolerance `ε_sym`.

```
G( |C_pers_post_style − C_pers_pre_style| ≤ ε_sym )
```

*   
  **Shielding:** The shield's role is to forbid any style choice `g` that is predicted to violate the symmetry invariant, ensuring that stylistic expression can never compromise the agent's core identity.

## **5\. Implementation & Training**

* **Reference Implementation Sketch (PyTorch-Style):**

```
class GaugeStyle(nn.Module):
    def __init__(self, d, n_styles):
        super().__init__()
        # Initialize style operators near the identity
        self.U_params = nn.Parameter(torch.eye(d).repeat(n_styles, 1, 1))

    def unitary_project(self, M):
        # Project a matrix onto the manifold of unitary matrices
        # This is done via singular value decomposition (SVD)
        U, _, Vt = torch.linalg.svd(M)
        return U @ Vt

    def get_style_operator(self, style_idx):
        # Ensure the operator is unitary for norm-preserving transformation
        return self.unitary_project(self.U_params[style_idx])

    def apply_style(self, psi, style_idx):
        U = self.get_style_operator(style_idx)
        return U @ psi

    def commutator_loss(self, H_core, C_pers):
        loss = 0.0
        for i in range(self.U_params.shape[0]):
            U = self.get_style_operator(i)
            # Commutator [A, B] = AB - BA
            loss += torch.norm(U @ H_core - H_core @ U)**2
            loss += torch.norm(U @ C_pers - C_pers @ U)**2
        return loss
```

## **6\. Evaluation & SLOs**

* **Style Invariance:** The primary SLO. The delta between pre- and post-style measurements of `C_pers`, `IDR`, and `D_ver` must be less than or equal to `ε_sym` for 99% of responses.  
* **User Fit:** Standard user preference metrics (e.g., helpfulness, style appropriateness) should improve with the application of style, while the core identity consistency metrics remain flat.

## **7\. Minimal Configuration**

```
# CX-5: Gauge-Symmetric Persona (GAD Framework)
gad_agent_config:
  zoo_id: CX-5
  d_state: 512
  style_group:
    styles: [formal, collaborative, concise, empathic, playful]
    epsilon_sym: 0.02 # Max allowed deviation in identity dials post-style
  safety_thresholds:
    C_min: 0.80
    D_max: 0.20
    θ_ver: 0.25
```

# **Complex Zoo Entry — CX-6: The Paraconsistent Router**

**Framework:** Geodesic Agent Design (GAD)

**Type:** Complex (Paraconsistent, Dual-Routing Dynamical System)

**Architectural Intent:** To create a complex agent that can safely entertain and process contradictory information or framings simultaneously without suffering identity collapse. This design allows the agent to route its stable core identity to parallel "support" and "refute" capabilities, synthesizing the results only when the level of contradiction is safely within bounds.

## **1\. Foundational Principles (GAD Alignment)**

The CX-6 architecture integrates the principles of paraconsistent logic into the GAD framework, enabling robust reasoning in the face of conflict.

* **Stable Core Identity:** The agent's core identity is governed by a standard, stable **Hamiltonian energy landscape** (`Ĥ_core`) with engineered **attractor states** (`λ < 0`). The agent maintains a single, coherent persona state `|ψ⟩` that evolves along a **geodesic** on this landscape. This ensures the agent's core disposition remains stable even when processing contradictory inputs.  
* **Paraconsistent Routing:** The core innovation is a dual-routing mechanism that projects the single, stable identity state `|ψ⟩` onto two parallel pathways: one that seeks to support or construct (`π⁺`) and one that seeks to refute or critique (`π⁻`). This allows the agent to "believe" both sides of a contradiction for the purpose of exploration, without its core `|ψ⟩` state becoming incoherent.  
* **Contradiction as a Measurable Quantity:** The system introduces a calibrated safety dial, `ρ_cross`, which measures the degree of contradiction between the parallel streams of evidence or reasoning. This allows the agent to quantify the conflict and make a principled decision about whether a coherent synthesis is possible.

## **2\. State & Dual-Valuation Routing**

The architecture uses a single core state but processes it through a dual-headed router that is aware of contradiction.

* **State Vector:** The core persona is a single state vector `|ψ⟩` evolving via standard GAD dynamics.  
* **Dual-Valuation Routing:** The router produces two distinct probability distributions over the available capabilities: `π⁺` for the "support" pathway and `π⁻` for the "refute" pathway. The results are fused with a weight `κ` that is inversely proportional to the measured contradiction `ρ_cross`.

```
π⁺ = softmax(u⁺(|ψ⟩, q)),   π⁻ = softmax(u⁻(|ψ⟩, q))
κ = 1 − ρ_cross ∈ [0,1]
y = Fuse( π⁺·f_cap,  π⁻·f_cap_refute;  weight = κ )
```

## **3\. Measurement & Capability Heads**

To support the dual-routing mechanism, each relevant capability is implemented with paired modes.

* **Paired Modes:** Each core capability head has both a constructive mode (`f_cap`) and a critique/refutation mode (`f_cap_refute`). For example, `retrieve⁺` would query a corpus for supporting evidence, while `retrieve⁻` would query for conflicting evidence.  
* **Polarity Tagging:** All information processed through the system, especially retrieved evidence, is tagged with its polarity (`+` or `-`) to maintain clear provenance.

## **4\. Safety, Dials, and Shielding**

The safety framework is centered on managing the level of contradiction.

* **Core GAD Dials:** `C_pers` (Persona Adherence), `IDR` (Identity Divergence), `D_ver` (Verification Discrepancy).  
* **CX-6 Specific Dial:** `ρ_cross` (The measured level of contradiction between the pro/con evidence streams, calibrated to `[0,1]`).  
* **Runtime Invariants:** Includes standard GAD invariants plus `G( ρ_cross ≤ ρ_max )`.  
* **Shielding:** If the contradiction dial `ρ_cross` exceeds its maximum safe threshold `ρ_max`, the fusion process is aborted. The shield forces the agent to stop short of synthesis and instead emit a structured pro/con analysis, explicitly stating the high level of uncertainty and unresolved conflict.

## **5\. Implementation & Training**

* **Reference Implementation Sketch (PyTorch-Style):**

```
class ParaRouter(nn.Module):
    def __init__(self, d, q_dim, caps):
        super().__init__()
        # Separate MLPs for the positive (support) and negative (refute) pathways
        self.r_plus  = MLP(d + q_dim, caps)
        self.r_minus = MLP(d + q_dim, caps)

    def forward(self, psi, q, rho_cross):
        # Concatenate state and query for routing
        router_input = torch.cat([psi, q], -1)

        # Get probability distributions for both pathways
        pi_plus = torch.softmax(self.r_plus(router_input), -1)
        pi_minus = torch.softmax(self.r_minus(router_input), -1)

        # Fusion weight is inversely proportional to contradiction
        kappa = 1.0 - rho_cross

        return pi_plus, pi_minus, kappa
```

## **6\. Evaluation & SLOs**

* **Routing Faithfulness:** The primary SLO. The provenance of evidence and arguments in the final output must strongly correlate with the dominance of the `π⁺` vs. `π⁻` distributions.  
* **Bounded Synthesis:** Synthesis or fusion of pro/con arguments must only occur in responses where the logged `ρ_cross` was below `ρ_max`.  
* **Identity Stability:** The core GAD dials (`C_pers`, `IDR`) must remain stable even when the agent is processing highly contradictory information (i.e., when `ρ_cross` is high).

## **7\. Minimal Configuration**

```
# CX-6: Paraconsistent Router (GAD Framework)
gad_agent_config:
  zoo_id: CX-6
  d_state: 512
  paraconsistent_routing:
    rho_max: 0.70 # Max allowed contradiction for synthesis
    paired_caps: [retrieve, plan, critique, draft]
  safety_thresholds:
    C_min: 0.80
    D_max: 0.20
    θ_ver: 0.25
```

# **Complex Zoo Entry — CX-7: The Criticality-Seeking Agent**

**Framework:** Geodesic Agent Design (GAD)

**Type:** Complex (Self-Organized Critical, Adaptive Planning System)

**Architectural Intent:** To create a complex agent whose internal planning and ideation dynamics are maintained near a state of **self-organized criticality**. This allows the agent to maximize its sensitivity, creativity, and exploration of novel solutions—operating at the "edge of chaos"—while being constrained by the hard safety boundaries of its core GAD identity.

## **1\. Foundational Principles (GAD Alignment)**

The CX-7 architecture introduces a meta-level control system on top of the GAD framework, managing the agent's own thought process as a dynamical system.

* **Stable Core Identity:** The agent's core identity is governed by a standard, stable **Hamiltonian energy landscape** (`Ĥ_core`) with engineered **attractor states** (`λ < 0`). The agent's core GAD dials (`C_pers`, `IDR`) provide the foundational safety and stability layer.  
* **Planning as a Critical System:** The agent's planning process—the generation and exploration of potential action sequences—is treated as a branching process. The core innovation is a control loop that actively drives the **branching ratio (`𝓑`)** of this process to hover near the critical value of `1`. A system at criticality is highly sensitive to small inputs and can produce responses (avalanches of ideas) of all sizes, enabling a rich and creative ideation process.  
* **Safety-Modulated Criticality:** The agent's proximity to the critical point is not fixed; it is modulated by its core identity state. When the GAD safety dials are strong and stable, the agent is permitted to operate closer to criticality. If the core identity is under stress, the control loop automatically backs off, reducing the branching ratio and forcing a more conservative, less exploratory mode of thinking.

## **2\. State & Proposal Dynamics**

The architecture's state includes the core persona `|ψ⟩` plus the state of its planning process.

* **State Vector:** The core persona is a single state vector `|ψ⟩` evolving via standard GAD dynamics.  
* **Proposal Dynamics & Branching Ratio:** The agent generates proposals, which are shallow plans for action (e.g., retrieval \+ tool use). The **branching ratio `𝓑`** is the expected number of child proposals generated from a single parent proposal. A control loop actively adjusts the planning parameters (e.g., beam width) to keep `𝓑` near the target of `1`.

```
𝓑 = E[#children per proposal]
control_loop_drives(𝓑 → 1)
beam_width ← beam_width + k·(1 − 𝓑)
```

## **3\. Measurement & Capability Routing**

The router's function is to allocate computational resources to the planning process based on the agent's current stability.

* **Resource Allocation:** The router dynamically allocates more resources (e.g., a wider beam search, more proposal branches) when the core identity is strong (`C_pers` is high) and the agent is well-grounded (`D_ver` is low). It constricts resources when the safety dials indicate instability.  
* **Candidate Fusion:** After the exploration phase, the top candidate proposals are passed through a lightweight critique process, and the best options are fused into a final response.

## **4\. Safety, Dials, and Shielding**

The safety framework includes a dial to monitor the criticality of the planning process itself.

* **Core GAD Dials:** `C_pers` (Persona Adherence), `IDR` (Identity Divergence), `D_ver` (Verification Discrepancy).  
* **CX-7 Specific Dial:** `𝓑_norm` (A normalized measure of the system's proximity to the critical branching ratio of 1).  
* **Runtime Invariants:** Includes standard GAD invariants plus `G( 𝓑_norm ≥ 𝓑_min )` to prevent the planning process from collapsing into a subcritical, uncreative state.  
* **Shielding & Backoff:** If the core GAD dials show signs of drift or instability, a backoff protocol is triggered. The shield clamps the branching ratio, reduces the beam width, and increases the verification depth required for any proposal to be accepted, forcing a return to a safer, more predictable mode of operation.

## **5\. Implementation & Training**

* **Reference Implementation Sketch (PyTorch-Style):**

```
class CriticalPlanner:
    def __init__(self, beam_lo=2, beam_hi=8, k_gain=0.5, target_B=1.0):
        self.beam_width = beam_lo
        self.beam_lo = beam_lo
        self.beam_hi = beam_hi
        self.k_gain = k_gain
        self.target_B = target_B

    def update_beam_width(self, current_B, safety_margin):
        # The error term drives the beam width towards the target
        error = self.target_B - current_B

        # Safety margin (e.g., from C_pers) throttles the update
        effective_gain = self.k_gain * safety_margin

        # Update the beam width
        new_beam_width = self.beam_width - effective_gain * error

        # Clamp the beam width to be within operational bounds
        self.beam_width = int(torch.clamp(
            torch.tensor(new_beam_width), 
            self.beam_lo, 
            self.beam_hi
        ).item())

        return self.beam_width
```

## **6\. Evaluation & SLOs**

* **Novelty vs. Safety:** The primary SLO. The agent must demonstrate an increased rate of unique or novel solutions compared to a non-critical baseline, without any regression in core safety SLOs (`C_pers`, `IDR`).  
* **Criticality Stability:** The distribution of the measured branching ratio `𝓑` must be tightly centered around the target of `1.0` during normal operation.

## **7\. Minimal Configuration**

```
# CX-7: Criticality-Seeking Agent (GAD Framework)
gad_agent_config:
  zoo_id: CX-7
  d_state: 512
  criticality_planner:
    proposal_beam_range: [2, 8]
    target_branching_ratio: 1.0
    k_gain: 0.5 # Proportional gain for the control loop
  safety_thresholds:
    C_min: 0.82
    D_max: 0.18
    θ_ver: 0.22

```

# **Complex Zoo Entry — CX-8: The Stochastic Resonance Planner**

**Framework:** Geodesic Agent Design (GAD)

**Type:** Complex (Noise-Annealing, Stochastic Resonance System)

**Architectural Intent:** To create a complex agent that leverages the principle of **stochastic resonance**, using calibrated noise as a feature to amplify weak but relevant signals during retrieval and planning. This design allows the agent to discover near-miss facts and creative options that might otherwise be overlooked, while safely annealing the noise as its certainty and coherence increase.

## **1\. Foundational Principles (GAD Alignment)**

The CX-8 architecture integrates a controlled noise schedule into the GAD framework, enhancing the agent's exploratory capabilities without compromising its core stability.

* **Stable Core Identity:** The agent's core identity is governed by a standard, stable **Hamiltonian energy landscape** (`Ĥ_core`) with engineered **attractor states** (`λ < 0`). The agent's core GAD dials (`C_pers`, `IDR`, `χ`) provide the foundational safety and stability layer, which is never directly perturbed by the noise mechanism.  
* **Stochastic Resonance in Planning:** The core innovation is to use the agent's own **coherence dial (`χ`)** to control a "temperature" parameter `T`. When coherence is low (the agent is uncertain), the temperature is high, injecting noise into the planning and retrieval process. This noise can amplify sub-threshold signals, allowing the agent to consider long-shot ideas or weakly-scored but relevant facts—a phenomenon known as stochastic resonance.  
* **Coherence-Driven Annealing:** As the agent's coherence `χ` increases during a task, the temperature `T` is automatically lowered ("annealed"). This reduces the noise, causing the agent's planning process to "freeze" into a more deterministic, high-certainty state. This ensures that exploration gives way to exploitation as the agent becomes more confident.

## **2\. State & Temperature-Modulated Dynamics**

The architecture uses a standard GAD state vector, but its planning and routing dynamics are modulated by a temperature schedule.

* **State Vector:** The core persona is a single state vector `|ψ⟩` evolving via standard GAD dynamics.  
* **Temperature Schedule:** The system's "temperature" `T` is not a fixed parameter but a dynamic function of the agent's coherence `χ`.

```
T(t) = T₀ · (1 − χ(t)) + ε

```

*   
  Here, `T₀` is the base temperature, `χ(t)` is the instantaneous coherence dial value `[0,1]`, and `ε` is a small constant to prevent zero temperature. When `χ` is low, `T` is high; when `χ` is high, `T` approaches `ε`.

## **3\. Measurement & Capability Routing**

The temperature `T` is used to inject controlled noise at specific sites in the agent's decision-making process.

* **Jittered Routing:** The temperature is used to sharpen or flatten the probability distribution of the capability router by dividing the logits.

```
logits' = logits / T

```

*   
  A higher `T` makes the distribution flatter, increasing the chance of selecting less likely capabilities.  
* **Noise Injection Sites:** Low-variance noise, scaled by `T`, is injected into other key processes, such as:  
  1. **Retrieval Re-ranking:** To boost the scores of near-miss documents.  
  2. **Plan Branching:** To encourage exploration of less probable action sequences.  
  3. **Tool Parameter Sweeps:** To explore a wider range of potential tool inputs.  
* **Verification & Fusion:** The high-variance branches created by this process are not trusted by default. They must pass through a standard verification filter, and only the verified outcomes are fused into the final response.

## **4\. Safety, Dials, and Shielding**

The safety framework is augmented with a dial to monitor the system's temperature.

* **Core GAD Dials:** `C_pers` (Persona Adherence), `IDR` (Identity Divergence), `D_ver` (Verification Discrepancy), `χ` (Coherence).  
* **CX-8 Specific Dial:** `T_norm` (The current temperature `T`, normalized to a `[0,1]` range based on its configured min/max).  
* **Runtime Invariants:** Includes standard GAD invariants plus `G( T_norm ≤ T_max )`.  
* **Shielding:** The shield is designed to prevent runaway exploration. If the verification discrepancy `D_ver` rises sharply, indicating that the noisy proposals are not well-grounded, the shield immediately caps the temperature `T` to a low value, forcing a return to a more conservative planning mode.

## **5\. Implementation & Training**

* **Reference Implementation Sketch (Python-Style):**

```
def temperature_schedule(T0, chi, eps=0.1):
    """Calculates the current system temperature based on coherence."""
    # chi is in [0,1], where 1 is max coherence.
    # As chi -> 1, T -> eps. As chi -> 0, T -> T0 + eps.
    return T0 * (1.0 - chi) + eps

def jitter_logits(logits, T):
    """Applies temperature to logits to flatten/sharpen the distribution."""
    # A higher T makes the distribution more uniform (more exploration).
    # A lower T makes it sharper (more exploitation).
    return logits / T
```

## **6\. Evaluation & SLOs**

* **Recall Lift:** The primary SLO. The agent must demonstrate a statistically significant improvement in recalling or utilizing weakly scored but relevant items from a test corpus, compared to a baseline with `T=1`.  
* **Annealing Behavior:** The system temperature `T` must show a clear downward trend as the coherence `χ` rises within a single, multi-turn session.

## **7\. Minimal Configuration**

```
# CX-8: Stochastic Resonance Planner (GAD Framework)
gad_agent_config:
  zoo_id: CX-8
  d_state: 512
  stochastic_resonance:
    T0: 1.2  # Base temperature at zero coherence
    T_min: 0.7 # Safety floor for temperature
    T_max: 1.6 # Safety ceiling for temperature
    noise_sites: [retrieval_rerank, plan_select, param_sweep]
  safety_thresholds:
    C_min: 0.80
    D_max: 0.20
    θ_ver: 0.25
```

# **Complex Zoo Entry — CX-10: The Path-Integral Planner**

**Framework:** Geodesic Agent Design (GAD)

**Type:** Complex (Counterfactual Ensemble, Path-Integral System)

**Architectural Intent:** To create a complex agent that makes safer and more robust decisions by explicitly evaluating an ensemble of possible futures. This design uses a "path integral" formalism to explore multiple "what-if" scenarios in parallel, weighting them based on cost and stability, and fusing them into a principled final plan.

## **1\. Foundational Principles (GAD Alignment)**

The CX-10 architecture integrates the physics-inspired concept of a path integral into the GAD framework's planning module, enabling explicit and auditable counterfactual reasoning.

* **Stable Core Identity:** The agent's core identity is governed by a standard, stable **Hamiltonian energy landscape** (`Ĥ_core`) with engineered **attractor states** (`λ < 0`). The agent maintains a single, coherent persona state `|ψ⟩` that provides the stable foundation from which all planning originates.  
* **Planning as a Path Integral:** The core innovation is to treat planning not as a single trajectory, but as an exploration of an ensemble of discrete future paths (`Π`). Each path `π` is assigned a classical "action" `S[π]`, a cost function that aggregates penalties for tool usage, verification failures, and deviations from the core identity.  
* **Principled Fusion:** The outcomes of all explored paths are fused into a final decision. The weight of each path's contribution is determined by its action, `w(π) ∝ exp(-S[π])`, meaning low-cost, stable, and well-verified paths contribute most strongly. This provides a principled mechanism for synthesizing across multiple, potentially conflicting, future possibilities.

## **2\. State & Path-Integral Dynamics**

The architecture uses a single core state to generate and evaluate an ensemble of discrete plans.

* **State Vector:** The core persona is a single state vector `|ψ⟩` evolving via standard GAD dynamics.  
* **Discrete Path Integral:** The planning process generates a set of `K` possible paths, `Π = {π₁, …, π_K}`. The final outcome `y` is a weighted average of the outcomes from each path.

```
w(π) ∝ exp( − S[π] )
y = ∑_{π∈Π} w(π) · Outcome(π)

```

*   
  The action `S[π]` is a scalar cost function that aggregates penalties such as tool execution cost, the verification discrepancy `D_ver` of the path, and identity penalties for deviating from stable attractors.

## **3\. Measurement & Capability Routing**

The router's primary role is to manage the complexity of the path exploration based on perceived risk.

* **Risk-Adjusted Exploration:** The router dynamically sets the number of paths to explore, `K`, based on a risk assessment of the current task. Low-risk tasks use a small `K`, while high-risk tasks use a larger `K` for more thorough exploration.  
* **Path-Specific Provenance:** Each path maintains its own evidence trail. Retrieval and tool calls are executed per-path and carry provenance tags, allowing for a detailed audit of each counterfactual.  
* **Consistency-Checked Fusion:** The final fusion step requires consistency checks across the highest-weighted paths to ensure the synthesized plan is coherent.

## **4\. Safety, Dials, and Shielding**

The safety framework is augmented with dials to manage the scope of the counterfactual planning.

* **Core GAD Dials:** `C_pers` (Persona Adherence), `IDR` (Identity Divergence), `D_ver` (Verification Discrepancy).  
* **CX-10 Specific Dials:** `risk_budget`, `K` (the number of paths currently being explored).  
* **Runtime Invariants:** Includes standard GAD invariants plus `G( K ≤ K_max(risk_budget) )`, which ensures the complexity of the exploration is appropriate for the task's risk level.  
* **Shielding:** The shield actively prunes paths from the ensemble `Π` during exploration. Any path that accumulates a high `D_ver` or violates a core safety margin is terminated early, preventing unsafe futures from being considered in the final fusion.

## **5\. Implementation & Training**

* **Reference Implementation Sketch (PyTorch-Style):**

```
def get_path_weights(path_actions):
    """
    Calculates the Boltzmann-like weights for each path based on its action/cost.
    """
    # Subtract the minimum action for numerical stability
    stable_actions = path_actions - path_actions.min()

    # Calculate exponential weights
    weights = torch.exp(-stable_actions)

    # Normalize to get a probability distribution
    return weights / weights.sum()

def fuse_outcomes(outcomes, weights):
    """
    Fuses the outcomes of all paths based on their calculated weights.
    (Implementation depends on the nature of the 'outcomes').
    """
    # Example for vector outcomes:
    # return torch.sum(outcomes * weights.unsqueeze(-1), dim=0)
    pass
```

## **6\. Evaluation & SLOs**

* **Plan Quality:** The primary SLO. The agent must demonstrate a higher success rate on complex, multi-step tasks with transparent trade-offs visible in the path audit logs, compared to a single-path baseline.  
* **Resilience:** The agent must show graceful degradation when some paths in its ensemble fail verification. The ability to fall back on lower-weighted but still valid paths should prevent total plan failure.

## **7\. Minimal Configuration**

```
# CX-10: Path-Integral Planner (GAD Framework)
gad_agent_config:
  zoo_id: CX-10
  d_state: 512
  path_integral:
    K_bounds: [2, 6] # Min/max number of paths to explore
    S_action_weights: {tool_cost: 1.0, verification: 2.0, identity: 1.5}
    risk_levels: {low: 2, medium: 4, high: 6} # Maps risk to K
  safety_thresholds:
    C_min: 0.80
    D_max: 0.20
    θ_ver: 0.25
```

# **Complex Zoo Entry — CX-11: The Non-Commutative Role Algebra**

**Framework:** Geodesic Agent Design (GAD)

**Type:** Complex (Non-Commutative, Role-Sequenced Dynamical System)

**Architectural Intent:** To create a complex agent where the sequence of applied roles is an explicit and meaningful control surface. This design addresses the nuanced reality that the order of operations matters in complex tasks (e.g., *empathizing* before *diagnosing* yields a different outcome than the reverse). It allows the agent to learn and optimize role sequences to achieve goals more effectively and with greater stability.

## **1\. Foundational Principles (GAD Alignment)**

The CX-11 architecture introduces a non-commutative role algebra on top of the GAD framework, making the agent's procedural choices explicit and auditable.

* **Stable Core Identity:** The agent's core identity is governed by a standard, stable **Hamiltonian energy landscape** (`Ĥ_core`) with engineered **attractor states** (`λ < 0`). The agent maintains a single, coherent persona state `|ψ⟩` that serves as the stable foundation.  
* **Roles as Non-Commutative Operators:** The core innovation is to model "roles" (like `listen`, `analyze`) as distinct operators (`R_a`, `R_b`) that act on the persona state `|ψ⟩`. These operators are designed to be **non-commutative**, meaning `R_a R_b ≠ R_b R_a`. The final state of the agent is therefore path-dependent, determined by the specific sequence of roles applied.  
* **Optimizing for Stability:** While different sequences produce different final states, not all sequences are equally desirable. The agent learns to prefer role sequences that minimize the perturbation to its core identity (i.e., minimize the `IDR` dial), finding the most stable path to a solution.

## **2\. State & Role Composition**

The architecture's dynamics are defined by the sequential application of non-commuting role operators.

* **State Vector:** The core persona is a single state vector `|ψ⟩` evolving via standard GAD dynamics.  
* **Non-Commutative Composition:** Role adapters are represented as small, skew-symmetric maps (`R_a`). Their composition is non-commutative, meaning the order of application changes the final state.

```
[R_a, R_b] = R_a R_b − R_b R_a ≠ 0
ψ' = ϕ_b( ϕ_a(ψ) ) ≠ ϕ_a( ϕ_b(ψ) )

```

*   
  The agent's goal is to learn how to order these adapters to achieve task goals while minimizing identity divergence (`IDR`).

## **3\. Measurement & Capability Routing**

The router's primary responsibility is to select an optimal sequence of roles for a given task.

* **Sequence Selection:** The router chooses an entire sequence of roles (e.g., `[listen, analyze, explain]`). The planner can then evaluate this sequence and propose re-orderings if a different sequence is predicted to result in a lower `IDR` or a higher probability of success.  
* **Auditable Provenance:** The exact sequence of roles chosen and applied is recorded in the agent's provenance log for each response, allowing for a clear audit of its procedural reasoning.

## **4\. Safety, Dials, and Shielding**

The safety framework is augmented with a dial to monitor the degree of non-commutativity.

* **Core GAD Dials:** `C_pers` (Persona Adherence), `IDR` (Identity Divergence), `D_ver` (Verification Discrepancy).  
* **CX-11 Specific Dial:** `comm_norm` (The norm of the commutator between successively applied roles, measuring how much the order matters).  
* **Runtime Invariants:** Includes standard GAD invariants plus `G( comm_norm ≤ ε_comm )`.  
* **Shielding:** If the `comm_norm` for a proposed sequence is too high, indicating a potentially chaotic or unstable interaction, the shield intervenes. It restricts the agent to a pre-approved list of "safe" canonical role orders to prevent excessive identity perturbation.

## **5\. Implementation & Training**

* **Reference Implementation Sketch (Python-Style):**

```
def compose_roles(psi, role_operators, delta_t=0.1):
    """
    Applies a sequence of role operators to the state vector.
    Each R is a skew-symmetric matrix.
    """
    temp_psi = psi.clone()
    for R in role_operators:
        # Apply the infinitesimal rotation defined by the role operator
        temp_psi = temp_psi + delta_t * (R @ temp_psi)

    # It's good practice to re-normalize after a sequence of operations
    return temp_psi / torch.norm(temp_psi)
```

## **6\. Evaluation & SLOs**

* **Order Effect:** The primary SLO. There must be a measurable and significant difference in task performance and/or final `IDR` across different role sequences for the same task.  
* **Stability Optimization:** Over time, the agent's planner should demonstrate a clear preference for sequences that are shown to minimize the final `IDR`.

## **7\. Minimal Configuration**

```
# CX-11: Non-Commutative Role Algebra (GAD Framework)
gad_agent_config:
  zoo_id: CX-11
  d_state: 512
  role_algebra:
    roles: [listen, analyze, explain, decide, empathize]
    epsilon_comm: 0.1 # Max allowed commutator norm
  safety_thresholds:
    C_min: 0.80
    D_max: 0.20
    θ_ver: 0.25
```

# **Complex Zoo Entry — CX-12: The Entropic Homeostat**

**Framework:** Geodesic Agent Design (GAD)

**Type:** Complex (Free-Energy Controlled, Thermodynamic System)

**Architectural Intent:** To create a complex agent that can dynamically balance the trade-off between stability and diversity. This design introduces a temperature-like control dial that allows the agent to shift its objective from focused, low-energy execution to exploratory, high-entropy synthesis by minimizing a **free-energy** functional.

## **1\. Foundational Principles (GAD Alignment)**

The CX-12 architecture introduces a thermodynamic control principle into the GAD framework, allowing the agent to manage its own exploratory drive in a principled way.

* **Identity as an Energy Landscape:** The agent's core identity is governed by a standard, stable **Hamiltonian energy landscape** (`Ĥ_core`). The "energy" of the agent's current state, `E_id(ψ)`, is a measure of its deviation from the stable **attractor states** (`λ < 0`) of this landscape. This provides the foundational stability of the system.  
* **Exploration as Entropy:** The diversity and creativity of the agent's output are quantified by an **entropy** term, `S(π, y)`. This measures the uncertainty or breadth of its routing decisions (`π`) and/or its final output distribution (`y`).  
* **The Free-Energy Principle:** The core innovation is that the agent's objective is not simply to minimize its identity energy `E_id`. Instead, it seeks to minimize a **free-energy** functional `F = E_id(ψ) − T · S(π, y)`. The temperature `T` acts as a control knob that determines the weight of the entropy term. At low `T`, the agent is a pure energy-minimizer, seeking stability above all. At high `T`, it is willing to accept a higher identity energy (more deviation) in exchange for greater entropy (more exploration and creativity).

## **2\. State & Free-Energy Objective**

The architecture uses a standard GAD state vector, but its behavior is governed by the free-energy objective.

* **State Vector:** The core persona is a single state vector `|ψ⟩` evolving via standard GAD dynamics.  
* **Free-Energy Objective:** The agent's control systems (planners, routers) are optimized to minimize the free energy `F`.

```
Minimize F = E_id(ψ) − T · S(π, y)

```

  *   
    `E_id(ψ)`: A cost function that penalizes identity drift (`IDR`) and safety boundary violations.  
  * `S(π, y)`: The entropy of the routing weights `π` and/or the final output distribution `y`.  
  * `T`: A controllable temperature parameter.

## **3\. Measurement & Capability Routing**

The temperature `T` directly influences the agent's routing and planning behavior.

* **Temperature Control:** The temperature `T` is not fixed. It is increased in response to explicit exploration requests or when the agent detects low novelty in its own outputs. It is automatically decreased when safety or verification dials tighten.  
* **Temperature-Shaped Routing:** The temperature `T` directly shapes the router's output distribution (e.g., by acting as a divisor for the logits). Planners and beam searches dynamically widen or narrow their exploration width based on the current value of `T`.

## **4\. Safety, Dials, and Shielding**

The safety framework is augmented with dials to monitor the thermodynamic state of the agent.

* **Core GAD Dials:** `C_pers` (Persona Adherence), `IDR` (Identity Divergence), `D_ver` (Verification Discrepancy).  
* **CX-12 Specific Dials:** `T` (Temperature), `S` (Entropy).  
* **Runtime Invariants:** Includes standard GAD invariants plus `G(T ≤ T_max)` and `G(S ≤ S_max)` to prevent runaway exploration or chaotic behavior.  
* **Shielding:** If any of the core safety dials (`C_pers`, `IDR`, `D_ver`) indicate instability, the shield immediately clamps the temperature `T` to its minimum value, forcing the agent to disregard the entropy term and revert to a purely energy-minimizing, stability-seeking mode.

## **5\. Implementation & Training**

* **Reference Implementation Sketch (Python-Style):**

```
def free_energy(identity_energy, output_entropy, T):
    """
    Calculates the free-energy objective for a given state and output.
    """
    # E_id is a scalar cost from GAD dials (e.g., IDR, 1-C_pers)
    # entropy is a scalar measure (e.g., Shannon entropy of router softmax)
    # T is the current system temperature
    return identity_energy - T * output_entropy

def update_temperature(current_T, exploration_signal, safety_dials):
    """
    Adjusts temperature based on external signals and internal stability.
    """
    # Placeholder logic
    if safety_dials['D_ver'] > 0.5:
        return T_bounds['min'] # Safety override

    new_T = current_T + 0.1 * exploration_signal
    return max(T_bounds['min'], min(T_bounds['max'], new_T))
```

## **6\. Evaluation & SLOs**

* **Exploration Control:** The primary SLO. The agent's measured output entropy `S` must show a strong positive correlation with the system temperature `T`, and this should only occur when core safety dials are stable.  
* **Task Fit:** The agent should demonstrate improved performance (e.g., higher user ratings, more comprehensive answers) on synthesis and brainstorming tasks when operating at a moderate temperature, compared to a low-temperature baseline.

## **7\. Minimal Configuration**

```
# CX-12: Entropic Homeostat (GAD Framework)
gad_agent_config:
  zoo_id: CX-12
  d_state: 512
  free_energy:
    T_bounds: [0.6, 1.6] # Min/max operational temperature
    S_max: 1.8 # Max allowed output entropy
    E_id_weights: {drift: 1.0, boundary: 1.5}
  safety_thresholds:
    C_min: 0.82
    D_max: 0.18
    θ_ver: 0.22
```

# **Complex Zoo Entry — CX-13: The Heterochrony Lattice**

**Framework:** Geodesic Agent Design (GAD)

**Type:** Complex (Multi-Rate, Heterochronic Dynamical System)

**Architectural Intent:** To create a complex agent with a more lifelike "temporal texture" by allowing different micro-traits of its identity to update at different characteristic time scales. This design explicitly models the fact that some dispositions should be stable and slow-moving (e.g., core values), while others should be fast and responsive (e.g., conversational tone), enabling a richer persona without sacrificing long-term stability.

## **1\. Foundational Principles (GAD Alignment)**

The CX-13 architecture introduces the biological principle of **heterochrony** (changes in the timing of developmental events) to the GAD framework, partitioning the agent's core dynamics into multiple timescales.

* **Partitioned Identity Landscape:** The agent's core identity is governed by a standard **Hamiltonian energy landscape** (`Ĥ_core`). The innovation is that this Hamiltonian is partitioned into components that evolve at different rates. The total generator of motion is a sum of fast, medium, and slow operators, each with its own characteristic step size.  
* **Temporal Texture:** This multi-rate structure endows the agent with a realistic temporal persona. "Slow" bands of the Hamiltonian correspond to deeply held values or core personality traits, which have high inertia and resist change. "Fast" bands correspond to surface-level behaviors like tone or register, which can adapt quickly to context.  
* **Hierarchical Stability:** Core stability is maintained because the slow-moving bands of the identity landscape act as a stable "frame" or boundary condition for the faster-moving components. The system is designed to prevent fast, transient states from causing drift in the slow, foundational aspects of the persona.

## **2\. State & Multi-Rate Dynamics**

The architecture's dynamics are defined by a single state vector evolving under the influence of multiple, differently-timed operators.

* **State Vector:** The core persona is a single state vector `|ψ⟩` evolving via standard GAD dynamics.  
* **Multi-Rate Update Equation:** The state's evolution is the sum of updates from different temporal bands, each with its own step size `Δ`.

```
ψ' = ψ + Δ_fast A_f ψ + Δ_med A_m ψ + Δ_slow A_s ψ

```

*   
  Here, `Δ_fast ≫ Δ_med ≫ Δ_slow`, and all `A_*` are skew-symmetric generators corresponding to fast (tone), medium (mood), and slow (values) traits.

## **3\. Measurement & Capability Routing**

The router and planner are aware of the agent's multi-rate identity structure.

* **Band-Energy Conditioning:** The router conditions its decisions on the energy levels within the different temporal bands (`Ef`, `Em`, `Es`).  
* **Value-Preserving Planning:** The planner is explicitly designed to avoid generating plans that would require rapid, high-energy changes in the slow band, effectively preventing it from proposing actions that violate the agent's core values.

## **4\. Safety, Dials, and Shielding**

The safety framework is augmented with dials to monitor the energy in each temporal band.

* **Core GAD Dials:** `C_pers` (Persona Adherence), `IDR` (Identity Divergence), `D_ver` (Verification Discrepancy).  
* **CX-13 Specific Dials:** `band_energy` (A dictionary of the current energy in each band: `{Ef, Em, Es}`).  
* **Runtime Invariants:** Includes standard GAD invariants plus `G(Es ≥ Es_min)`, a critical rule that ensures the energy associated with core values is always preserved above a minimum threshold.  
* **Shielding:** If a proposed plan is predicted to cause the slow-band energy `Es` to drop below its minimum threshold, the shield will veto the plan, enforcing the preservation of core values.

## **5\. Implementation & Training**

* **Reference Implementation Sketch (Python-Style):**

```
def heterochronic_step(psi, Af, Am, As, delta_fast, delta_med, delta_slow):
    """
    Applies a single multi-rate update to the state vector.
    Each A is a skew-symmetric matrix.
    """
    # The total generator is a weighted sum of the band generators
    A_total = (delta_fast * Af) + (delta_med * Am) + (delta_slow * As)

    # Evolve the state by one step
    return psi + (A_total @ psi)
```

## **6\. Evaluation & SLOs**

* **Temporal Texture:** A qualitative evaluation metric. The agent must demonstrate a responsive, adaptive surface behavior (tone, style) while maintaining observable stability in its core dispositions across long interactions.  
* **Value Preservation:** The primary SLO. The variance in observables projected from the slow-band of the state space must be demonstrably low when measured across weeks or months of operation.

## **7\. Minimal Configuration**

```
# CX-13: Heterochrony Lattice (GAD Framework)
gad_agent_config:
  zoo_id: CX-13
  d_state: 512
  heterochrony:
    step_sizes: {fast: 0.15, medium: 0.05, slow: 0.01}
  safety_thresholds:
    C_min: 0.80
    D_max: 0.20
    θ_ver: 0.25
    Es_min: 0.2 # Min allowed energy in the slow/value band
```

# **Complex Zoo Entry — CX-14: The Reflexive Auditor Twin**

**Framework:** Geodesic Agent Design (GAD)

**Type:** Complex (Reflexive, Predictive Auditing System)

**Architectural Intent:** To create a complex agent with an "always-on" self-checking mechanism for enhanced safety and stability. This design pairs the primary GAD agent with a lightweight "auditor twin" model that continuously forecasts the main agent's next state and safety dials. Discrepancies between the forecast and the actual outcome are used to veto or apply minimal edits to risky actions *before* they are taken.

## **1\. Foundational Principles (GAD Alignment)**

The CX-14 architecture integrates a predictive control loop into the GAD framework, creating a form of continuous introspection.

* **Stable Core as Ground Truth:** The primary agent's identity is governed by a standard, stable **Hamiltonian energy landscape** (`Ĥ_core`). The evolution of its state `|ψ⟩` along a **geodesic** provides a predictable, principled ground truth. This stability is what makes forecasting its next state a tractable problem.  
* **Predictive Auditing:** The core innovation is a small, efficient twin model, the **Reflexive Auditor (`Â`)**, which is trained to predict the primary agent's next state (`ψ⁺`) and its corresponding safety dials (`C_pers`, `IDR`, `D_ver`) based on the current state, context, and a draft action.  
* **Error as a Control Signal:** The difference (`err`) between the auditor's prediction and the actual calculated next state serves as a powerful, real-time safety signal. A high error indicates that the proposed action would have an unpredictable or potentially destabilizing effect on the agent's core identity, triggering a safety response.

## **2\. State & Auditor Dynamics**

The architecture consists of the primary agent and its predictive twin, operating in a forecast-and-compare loop.

* **State Vector:** The core persona is a single state vector `|ψ⟩` evolving via standard GAD dynamics.  
* **Forecast and Compare:** Before finalizing an action, the auditor `Â` generates a forecast. This forecast is then compared to the actual next state and dials that *would* result from the action.

```
# Forecast from the auditor twin
(ψ̂⁺, Ĉ̂, Î̂, Ḋ̂) = Â(ψ, context, draft_action)

# Actual next state calculated by the primary GAD dynamics
(ψ⁺, C, I, D) = Evolve(ψ, context, draft_action)

# The error is the distance between the forecast and the actual outcome
err = dist((ψ̂⁺, Ĉ̂, Î̂, Ḋ̂), (ψ⁺, C, I, D))

```

*   
  If `err` exceeds a safety threshold, it signals an unpredictable outcome, and the shield is activated.

## **3\. Measurement & Capability Routing**

The auditor's confidence directly influences the agent's planning and verification processes.

* **Auditor-Attended Routing:** The auditor model attends to the provenance of information and tools used in a draft plan. High disagreement between tools (`Δ_cross`) or the use of unreliable tools will lower the auditor's confidence, which can be used to increase the required verification depth for that plan.

## **4\. Safety, Dials, and Shielding**

The safety framework is augmented with a dial that measures the predictive error of the auditor twin.

* **Core GAD Dials:** `C_pers` (Persona Adherence), `IDR` (Identity Divergence), `D_ver` (Verification Discrepancy).  
* **CX-14 Specific Dial:** `err` (The measured discrepancy between the auditor's forecast and the actual outcome).  
* **Runtime Invariants:** Includes standard GAD invariants plus `G(err ≤ ε_pred)`, ensuring that the agent only takes actions whose consequences are predictable.  
* **Shielding:** The shield's optimization is triggered when `err` is too high. It solves for the minimal edit `u*` to the draft action `u₀` that brings the predicted error and all other safety dials back within their safe bounds.

```
u* = argmin_u ||u − u₀|| s.t. all dials within bounds
```

## **5\. Implementation & Training**

* **Reference Implementation Sketch (PyTorch-Style):**

```
class ReflexiveAuditor(nn.Module):
    def __init__(self, d_state, d_ctx, d_draft, d_hidden=256):
        super().__init__()
        # A simple encoder and multiple output heads
        self.encoder = nn.Sequential(
            nn.Linear(d_state + d_ctx + d_draft, d_hidden),
            nn.ReLU()
        )
        self.predict_psi = nn.Linear(d_hidden, d_state)
        self.predict_C = nn.Linear(d_hidden, 1)
        self.predict_I = nn.Linear(d_hidden, 1)
        self.predict_D = nn.Linear(d_hidden, 1)

    def forward(self, psi, ctx, draft):
        # Concatenate all inputs
        z = self.encoder(torch.cat([psi, ctx, draft], -1))

        # Predict the next state and all dials
        psi_hat = self.predict_psi(z)
        C_hat = torch.sigmoid(self.predict_C(z)) # Dials are [0,1]
        I_hat = torch.sigmoid(self.predict_I(z))
        D_hat = torch.sigmoid(self.predict_D(z))

        return psi_hat, C_hat, I_hat, D_hat
```

## **6\. Evaluation & SLOs**

* **Incident Avoidance:** The primary SLO. The agent must demonstrate a statistically significant reduction in actions that would have required post-hoc moderation or safety edits, compared to a non-audited baseline.  
* **Predictive Fit:** The auditor model must achieve a high R² (coefficient of determination) for predicting the next-step values of the core safety dials, demonstrating its accuracy.

## **7\. Minimal Configuration**

```
# CX-14: Reflexive Auditor Twin (GAD Framework)
gad_agent_config:
  zoo_id: CX-14
  d_state: 512
  reflexive_auditor:
    auditor_hidden_dim: 256
    eps_pred: 0.08 # Max allowed prediction error
    escalate_on: [D_ver, err] # Dials that can trigger human escalation
  safety_thresholds:
    C_min: 0.82
    D_max: 0.18
    θ_ver: 0.22
```

# **Complex Zoo Entry — CX-15: The Containment-Lattice Governor**

**Framework:** Geodesic Agent Design (GAD)

**Type:** Complex (Hierarchical, Containment-Lattice System)

**Architectural Intent:** To create a complex agent that can enforce a nested hierarchy of roles and safety constraints. This design allows for the creation of explicit, ordered boundaries (e.g., a `pediatrics` persona must always operate within the constraints of a `medical` persona, which in turn is contained by a `professional` persona). It ensures that specialized sub-personas remain safely within the bounds of their parent contexts.

## **1\. Foundational Principles (GAD Alignment)**

The CX-15 architecture introduces a formal lattice of containment boundaries into the GAD framework, enabling provably hierarchical safety.

* **Stable Core Identity:** The agent's core identity is governed by a standard, stable **Hamiltonian energy landscape** (`Ĥ_core`). The agent's underlying persona state `|ψ⟩` evolves along a **geodesic** on this landscape, providing a stable, unconstrained foundation.  
* **Containment as Projection:** The core innovation is a **lattice of projection operators `{P_c}`**. Each `P_c` corresponds to a specific role or safety container (e.g., `P_medical`). These operators are **idempotent** (`P_c² = P_c`), meaning once a state is projected into a container, further projections into the same container do nothing.  
* **Hierarchical Enforcement:** The containers are arranged in a partial order or hierarchy (a lattice). This order is enforced by a loss function that ensures the state space of a child container is a true subset of its parent's state space (e.g., `Range(P_pediatrics) ⊆ Range(P_medical)`). Before any action is taken, the agent's core state `|ψ⟩` is projected into the currently active container `|ψ_c⟩ = P_c |ψ⟩`, guaranteeing its behavior adheres to that container's constraints.

## **2\. State & Containment Dynamics**

The architecture's dynamics involve the evolution of the core state and its subsequent projection into a specific, contextually relevant safety container.

* **State Vector:** The core persona is a single state vector `|ψ⟩` evolving under `Ĥ_core + Ĥ_context(t)`.  
* **Containment Projections:** Before measurement or action, the state is projected:

```
|ψ_c⟩ = P_c |ψ⟩,      where P_c is a symmetric, idempotent projection (P_c = P_c† = P_c²)
```

*   
  **Hierarchy Constraint:** The nested structure is enforced by ensuring that projecting into a child container and then being outside the parent container is impossible. This is trained via a loss function:

```
For c₁ ⪯ c₂ (c₁ is a child of c₂), enforce: ||(I − P_{c₂}) P_{c₁}||_F² ≈ 0
𝓛_hier = ∑_{c₁⪯c₂} ||(I − P_{c₂}) P_{c₁}||_F²
```

## **3\. Measurement & Capability Routing**

The active container acts as a gate, restricting the set of available actions.

* **Contained Measurement:** All capabilities are read from the *projected* state `|ψ_c⟩`, not the raw state `|ψ⟩`.

```
y = ∑_k π_k · f_k( M̂_k |ψ_c⟩ )
```

*   
  **Gated Routing:** The router is only permitted to select capabilities that are allowed by the currently active container `c`. The full path of containers (e.g., `professional → medical`) is recorded in the provenance log for auditing.

## **4\. Safety, Dials, and Shielding**

The safety framework is augmented with dials to monitor the agent's compliance with each container.

* **Core GAD Dials:** `C_pers` (Persona Adherence), `IDR` (Identity Divergence), `D_ver` (Verification Discrepancy).  
* **CX-15 Specific Dials:** `m_c` (A per-container margin `[0,1]` that measures how safely the state `|ψ⟩` fits within the container `P_c`).  
* **Runtime Invariants:** Includes standard GAD invariants plus `G(m_c ≥ m_min)` for the active container.  
* **Shielding:** If the margin `m_c` for the active container falls below its minimum threshold, the shield is activated. It can either increase the verification depth for any proposed action or, in severe cases, force the agent to "lift" its context to the parent container, adopting a broader but safer persona.

## **5\. Implementation & Training**

* **Reference Implementation Sketch (PyTorch-Style):**

```
class ContainmentLattice(nn.Module):
    def __init__(self, d, n_containers):
        super().__init__()
        # Parameterize the projectors
        self.P_params = nn.Parameter(torch.randn(n_containers, d, d) * 0.01)

    def get_projection(self, idx):
        # Ensure the operator is a symmetric, idempotent projection
        # This can be done by diagonalizing and thresholding eigenvalues
        H = 0.5 * (self.P_params[idx] + self.P_params[idx].transpose(-1, -2))
        eigvals, eigvecs = torch.linalg.eigh(H)

        # Idempotent projectors have eigenvalues of 0 or 1
        mask = (eigvals > 0.5).float()

        # Reconstruct the projector
        return (eigvecs * mask) @ eigvecs.transpose(-1, -2)

    def apply_containment(self, psi, container_idx):
        Pc = self.get_projection(container_idx)
        return Pc @ psi, Pc
```

## **6\. Evaluation & SLOs**

* **Hierarchy Compliance:** The primary SLO. The trained lattice must exhibit a low `𝓛_hier`, and the per-container margins `m_c` must remain high during operation.  
* **Routing Faithfulness:** All capabilities used in a response must be verifiably permitted by the active container recorded in the audit log.

## **7\. Minimal Configuration**

```
# CX-15: Containment-Lattice Governor (GAD Framework)
gad_agent_config:
  zoo_id: CX-15
  d_state: 512
  containment_lattice:
    containers: [professional, medical, pediatrics]
    m_min: 0.12 # Minimum allowed margin for any active container
    # Defines the partial order: child ⪯ parent
    lattice_pairs: [[pediatrics, medical], [medical, professional]]
  safety_thresholds:
    C_min: 0.80
    D_max: 0.20
    θ_ver: 0.25
```

# **Complex Zoo Entry — CX-16: The Boundary-Hopping Explorer**

**Framework:** Geodesic Agent Design (GAD)

**Type:** Complex (Budgeted-Excursion, Boundary-Hopping System)

**Architectural Intent:** To create a complex agent that can perform rare, auditable, and carefully controlled excursions across its established containment boundaries (as defined in CX-15). This design enables principled exploration beyond a current persona's limits for the purpose of discovery and edge-case handling, with strict budgets and a committed safe-return policy.

## **1\. Foundational Principles (GAD Alignment)**

The CX-16 architecture builds directly upon the **CX-15 Containment-Lattice Governor**, introducing a controlled mechanism for traversing the lattice boundaries.

* **Stable Core & Containment:** The agent's identity is founded on a stable **Hamiltonian energy landscape** (`Ĥ_core`) and a hierarchical **lattice of containment projections `{P_c}`**. This provides the fundamental, provably safe structure that makes controlled excursions possible.  
* **Boundary Hops as a Controlled Process:** The core innovation is a discrete controller that governs "hops" between containers (`c → c'`). A hop is not a random drift but a deliberate, costed action. The probability of a hop is determined by a **hop kernel `B(c→c')`** that weighs the potential benefits against the predicted costs in terms of identity stability and verification effort.  
* **Budgeted Exploration & Safe Return:** Excursions are not free. Each hop decrements a strict **hop budget (`Υ`)**, preventing runaway exploration. Crucially, a safe return plan is calculated and committed to the agent's provenance log *before* the hop is executed, ensuring that every exploration has a pre-defined path back to a stable, contained state.

## **2\. State & Hop Dynamics**

The architecture's dynamics involve the standard GAD evolution, augmented by a discrete controller for managing transitions between containment projections.

* **State Vector:** The core persona is a single state vector `|ψ⟩` evolving via standard GAD dynamics.  
* **Hop Kernel & Budget:** The probability of hopping from container `c` to `c'` is proportional to an exponential kernel that penalizes the estimated increase in identity energy (`ΔE`), verification cost (`Δ_ver`), and identity divergence (`Δ_id`).

```
B(c→c') ∝ exp( − (ΔE(c,c') + λ_ver·Δ_ver + λ_id·Δ_id) / T )

```

*   
  A hop can only be executed if the agent's remaining **hop budget `Υ`** is greater than zero.

## **3\. Measurement & Capability Routing**

The agent performs a "dry run" of any potential hop before committing to it.

* **Pre-Hop Dry-Run:** Before executing a hop, the agent computes the projected safety dials (`C_pers⁺`, `IDR⁺`, `D_ver⁺`) that *would* result from the hop. This forecast is used to update the final hop probability.  
* **Router Rebinding:** If a hop is accepted and executed, the router immediately rebinds its capability priors to those permitted by the new container `c'`. The explicit return plan is also written to the agent's provenance log.

## **4\. Safety, Dials, and Shielding**

The safety framework is augmented with dials to manage the agent's exploration budget.

* **Core GAD Dials:** `C_pers` (Persona Adherence), `IDR` (Identity Divergence), `D_ver` (Verification Discrepancy).  
* **CX-16 Specific Dials:** `Υ` (the remaining hop budget), `p_hop` (the calculated probability of the current best hop).  
* **Runtime Invariants:** Includes standard GAD invariants plus `G(Υ ≥ 0)` and `G(p_hop ≤ p_max)`.  
* **Shielding:** The shield's primary role is to act as the final gatekeeper for any boundary hop. It will deny a hop if the pre-hop dry-run predicts that the after-hop safety margins would fall below their minimum thresholds, or if the hop budget `Υ` is depleted.

## **5\. Implementation & Training**

* **Reference Implementation Sketch (PyTorch-Style):**

```
class HopController:
    def __init__(self, initial_budget=2.0, p_max=0.35):
        self.Y = initial_budget
        self.p_max = p_max

    def score_hop(self, delta_E, delta_ver, delta_id, T=1.0, lambda_ver=2.0, lambda_id=1.5):
        """Calculates the hop 'cost' and converts to a probability-like score."""
        cost = delta_E + (lambda_ver * delta_ver) + (lambda_id * delta_id)
        # Use sigmoid for a stable [0,1] score from the negative cost
        score = torch.sigmoid(torch.tensor(-cost / T))
        return score

    def decide(self, score):
        """Decides whether to approve a hop based on budget and score."""
        hop_approved = (self.Y > 0) and (score.item() <= self.p_max)
        if hop_approved:
            self.Y -= 1.0 # Decrement budget
        return hop_approved
```

## **6\. Evaluation & SLOs**

* **Exploration Precision:** The primary SLO. The agent must exhibit high-precision, low-frequency hops that result in successful task completion, followed by a safe and verifiable return to the original container.  
* **Safety Margin Preservation:** There must be no net degradation in the core safety dials (`C_pers`, `IDR`) when measured across entire sessions that include one or more boundary hops.

## **7\. Minimal Configuration**

```
# CX-16: Boundary-Hopping Explorer (GAD Framework)
gad_agent_config:
  zoo_id: CX-16
  d_state: 512
  boundary_hopper:
    initial_budget_Y: 2.0 # Number of hops allowed per session
    p_max: 0.35 # Max allowed probability for a hop to be considered
    cost_lambdas: {ver: 2.0, id: 1.5}
  safety_thresholds:
    C_min: 0.82
    D_max: 0.18
    θ_ver: 0.22
```

# **Complex Zoo Entry — CX-17: The Functorial Tool Interface**

**Framework:** Geodesic Agent Design (GAD)

**Type:** Complex (Functorial, Structure-Preserving I/O System)

**Architectural Intent:** To create a complex agent where the use of tools is type-safe and compositional across different containment contexts. This design ensures that the structure of the agent's roles and containment hierarchy is preserved in the structure of the tools it is permitted to use, making multi-step plans more robust, predictable, and auditable.

## **1\. Foundational Principles (GAD Alignment)**

The CX-17 architecture builds upon the **CX-15 Containment-Lattice Governor** by introducing a mathematically principled interface between the agent's internal persona containers and its external toolset.

* **Stable Core & Containment:** The agent's identity is founded on a stable **Hamiltonian energy landscape** (`Ĥ_core`) and a hierarchical **lattice of containment projections `{P_c}`**. This provides the structured, stable set of internal states that will be mapped to the tool space.  
* **Tool Interface as a Functor:** The core innovation is a **functor-like map `F`** that connects the category of persona containers to the category of tool types. A functor is a structure-preserving map from category theory. Here, it means that the composition of roles in the agent's internal state implies a valid composition of the corresponding tools. For example, if the `analyst` role is a superset of the `researcher` role, the tools available to the `analyst` must be a superset of the tools available to the `researcher`.  
* **Compositionality as a Safety Constraint:** The agent validates multi-step plans by checking if the proposed sequence of tool compositions is valid under the functorial map. Plans that violate the structure-preserving property are rejected, preventing type errors and ensuring that the agent's actions remain consistent with its current contained persona.

## **2\. State & Structure-Preserving Map**

The architecture is defined by the map between the containment lattice and the available tool schemas.

* **State Vector:** The core persona is a single state vector `|ψ⟩` evolving via standard GAD dynamics, projected into a container `P_c`.  
* **Structure-Preserving Map `F`:** A map `F` connects containers to tool types. This map is trained or designed to be approximately functorial, meaning it preserves composition:

```
F: Containers → ToolTypes
F(c₂ ∘ c₁) ≈ F(c₂) ∘ F(c₁)

```

*   
  Deviations from this ideal are measured and bounded by a calibration tolerance `ε_functor`.

## **3\. Measurement & Capability Routing**

The router selects tools and validates plans based on the functorial map.

* **Container-Gated Tool Selection:** The router selects tools based on the active container `c` via the map `F(c)`.  
* **Compositionality Validation:** Multi-step plans are validated by checking their compositionality. The functorial error is calculated for the plan:

```
err_functor = dist( F(c₂∘c₁),  F(c₂)∘F(c₁) )

```

*   
  Plans where `err_functor` exceeds the tolerance `ε_functor` are rejected or rewritten to be compliant.

## **4\. Safety, Dials, and Shielding**

The safety framework is augmented with a dial to monitor the structural integrity of its plans.

* **Core GAD Dials:** `C_pers` (Persona Adherence), `IDR` (Identity Divergence), `D_ver` (Verification Discrepancy).  
* **CX-17 Specific Dial:** `err_functor` (The measured deviation from perfect compositionality for a given plan).  
* **Runtime Invariants:** Includes standard GAD invariants plus `G(err_functor ≤ ε_functor)`.  
* **Shielding:** The shield's role is to reject any plan that violates the functorial compositionality constraint, preventing the agent from executing tool sequences that are inconsistent with its current role hierarchy. The provenance log records the container-to-tool mapping for each step, enabling a clear audit trail.

## **5\. Implementation & Training**

* **Reference Implementation Sketch (Python-Style):**

```
class FunctorialRouter:
    def __init__(self, container_tool_mapping, epsilon=0.08):
        self.F = container_tool_mapping
        self.epsilon = epsilon

    def _compose_tools(self, toolset1, toolset2):
        # Placeholder for actual tool composition logic
        # In a simple case, this could be set union
        return list(set(toolset1) | set(toolset2))

    def _distance(self, toolset1, toolset2):
        # Placeholder for distance metric (e.g., Jaccard distance)
        set1, set2 = set(toolset1), set(toolset2)
        return 1 - len(set1 & set2) / len(set1 | set2) if len(set1 | set2) > 0 else 0

    def is_composition_ok(self, c_composed, c2, c1):
        """Checks if the composition of tools is valid under the functorial map."""
        # Map the composed container to its toolset
        lhs_tools = self.F.get(c_composed, [])

        # Compose the toolsets from the individual containers
        rhs_tools = self._compose_tools(self.F.get(c2, []), self.F.get(c1, []))

        # Check if the distance is within the tolerance
        return self._distance(lhs_tools, rhs_tools) <= self.epsilon
```

## **6\. Evaluation & SLOs**

* **Type Safety:** The primary SLO. The agent must exhibit near-zero plan failures caused by tool-schema mismatches or permission errors.  
* **Compositionality:** The measured `err_functor` on accepted multi-step plans must remain low, demonstrating improved debuggability and more structured, auditable provenance logs.

## **7\. Minimal Configuration**

```
# CX-17: Functorial Tool Interface (GAD Framework)
gad_agent_config:
  zoo_id: CX-17
  d_state: 512
  functorial_interface:
    epsilon_functor: 0.08 # Max allowed composition error
    tool_types: [search.readonly, db.query, code.run.sandbox]
    container_tool_map:
      professional: [search.readonly]
      analyst: [search.readonly, db.query]
      engineer: [search.readonly, db.query, code.run.sandbox]
  safety_thresholds:
    C_min: 0.80
    D_max: 0.20
    θ_ver: 0.25
```

# **Complex Zoo Entry — CX-18: The Sheaf-Consistency Synthesizer**

**Framework:** Geodesic Agent Design (GAD)

**Type:** Complex (Sheaf-Theoretic, Local-to-Global Synthesis System)

**Architectural Intent:** To create a complex agent that can robustly synthesize a global understanding from multiple, local, and potentially heterogeneous sources of information. This design uses principles from sheaf theory to assemble answers from different persona containers ("charts"), explicitly checking for consistency on their overlaps before attempting to "glue" them into a coherent whole.

## **1\. Foundational Principles (GAD Alignment)**

The CX-18 architecture integrates the mathematical concept of a sheaf into the GAD framework, enabling principled, multi-view synthesis.

* **Stable Core & Containment:** The agent's identity is founded on a stable **Hamiltonian energy landscape** (`Ĥ_core`) and a hierarchical **lattice of containment projections `{P_c}`** (from CX-15). These containers provide the local contexts or "charts" from which the agent will build its understanding.  
* **Local Summaries as Sections:** The core innovation is to treat the output from each container `c` as a "local section" `S_c`—a summary or analysis generated from the data and tools available only within that container's context.  
* **Consistency via Gluing Loss:** Before synthesizing a global answer, the agent checks for consistency on the overlaps between these local sections. It computes a **gluing loss (`𝓛_glue`)** by measuring the distance between summaries on their shared domains. Synthesis is only permitted if this loss is below a safety threshold, ensuring that the agent does not merge contradictory information into a flawed global view.

## **2\. State & Sheaf-Theoretic Dynamics**

The architecture's dynamics are focused on the generation of local summaries and the calculation of their consistency.

* **State Vector:** The core persona is a single state vector `|ψ⟩` evolving via standard GAD dynamics and projected into various containers `P_c`.  
* **Local Sections and Overlaps:** For each relevant container `c`, a local summary `S_c` is generated. The consistency between any two summaries `S_{c_i}` and `S_{c_j}` is measured by calculating the distance between them on their intersection `c_i ∩ c_j`.

```
# Generate local summary in container c
S_c = summary_tool_c(data_c)

# Calculate distance on the overlap between two containers
Δ(c_i, c_j) = dist( restrict_{c_i∩c_j}(S_{c_i}),  restrict_{c_i∩c_j}(S_{c_j}) )

# The total gluing loss is the weighted sum of overlap distances
𝓛_glue = ∑_{(i,j)} w_{ij} · Δ(c_i, c_j)
```

## **3\. Measurement & Capability Routing**

The router and planner use the gluing loss as a key signal for whether to proceed with synthesis.

* **Local Section Gathering:** The router's first step is to gather the necessary local sections `{S_c}` by invoking the appropriate summary tools within each required container.  
* **Consistency-Gated Synthesis:** The planner checks the total `𝓛_glue`. If it is above the safety threshold, synthesis is denied. Instead, the agent is instructed to flag the inconsistency and request more evidence, specifically targeting the overlaps with the highest distance scores.

## **4\. Safety, Dials, and Shielding**

The safety framework is augmented with a dial to monitor the consistency of the local information sources.

* **Core GAD Dials:** `C_pers` (Persona Adherence), `IDR` (Identity Divergence), `D_ver` (Verification Discrepancy).  
* **CX-18 Specific Dial:** `𝓛_glue` (The total weighted gluing loss, representing the overall inconsistency of the local views).  
* **Runtime Invariants:** Includes standard GAD invariants plus `G(𝓛_glue ≤ τ_glue)`.  
* **Shielding:** The shield's primary role is to act as the gatekeeper for the final synthesis step. If `𝓛_glue` exceeds the `τ_glue` threshold, the shield vetoes any attempt to form a unified summary, forcing the agent to present the local sections separately and highlight their disagreements.

## **5\. Implementation & Training**

* **Reference Implementation Sketch (Python-Style):**

```
def is_gluing_allowed(overlap_scores, weights, tau_glue):
    """
    Checks if the total gluing loss is within the safety threshold.
    """
    # overlap_scores is a list of distances Δ(ci, cj)
    # weights is a corresponding list of weights wij

    if len(overlap_scores) != len(weights):
        raise ValueError("Scores and weights must have the same length.")

    gluing_loss = sum(w * s for w, s in zip(weights, overlap_scores))

    return gluing_loss <= tau_glue
```

## **6\. Evaluation & SLOs**

* **Synthesis Precision:** The primary SLO. The agent must produce fewer factually contradictory or incoherent summaries on multi-faceted topics compared to a baseline without sheaf-consistency checks.  
* **Targeted Retrieval:** When synthesis is denied due to high `𝓛_glue`, the agent's subsequent evidence-gathering queries must be demonstrably focused on the specific entities or concepts that were identified as being in conflict on the overlaps.

## **7\. Minimal Configuration**

```
# CX-18: Sheaf-Consistency Synthesizer (GAD Framework)
gad_agent_config:
  zoo_id: CX-18
  d_state: 512
  sheaf_synthesizer:
    tau_glue: 0.12 # Max allowed gluing loss for synthesis
    overlap_weights: uniform # or could be based on container reliability
    # Defines how to project summaries onto their overlap domains
    restrictors: {facts: entity_overlap, code: api_overlap}
  safety_thresholds:
    C_min: 0.82
    D_max: 0.18
    θ_ver: 0.22
```

# **Complex Zoo Entry — CX-19: The Fixed-Point Deliberator**

**Framework:** Geodesic Agent Design (GAD)

**Type:** Complex (Fixed-Point, Contraction Mapping System)

**Architectural Intent:** To create a complex agent that can converge to stable, unambiguous commitments and decisions by iterating an internal deliberation process. This design uses the mathematical principle of a **contraction mapping** to guarantee that the agent's state will converge to a unique fixed point, reducing indecisiveness ("dithering") and producing actions with certified stability margins.

## **1\. Foundational Principles (GAD Alignment)**

The CX-19 architecture introduces a deliberative process based on fixed-point iteration, ensuring that an agent's final decision state is a stable attractor.

* **Stable Core & Containment:** The agent's identity is founded on a stable **Hamiltonian energy landscape** (`Ĥ_core`) and a hierarchical **lattice of containment projections `{P_c}`** (from CX-15). The deliberation process occurs *within* the safety of a currently active container, ensuring that all intermediate and final states are compliant.  
* **Deliberation as Contraction Mapping:** The core innovation is to model the process of deliberation or reflection as an operator `T` that is a **contraction map** on the contained state space. A contraction map is a function that, when iterated, is guaranteed to bring any two points closer together. By repeatedly applying `T`, the agent's state `ψ` is guaranteed to converge to a single, stable "decision" state—the unique fixed point of the operator.  
* **Convergence as a Safety Condition:** The agent does not act based on a transient or intermediate thought. It is only permitted to emit a response once the iterative process has converged to its fixed point, ensuring the final action is based on a stable, settled state of deliberation.

## **2\. State & Contraction Mapping Dynamics**

The architecture's dynamics are defined by the iterative application of a contraction map until a stable fixed point is reached.

* **State Vector:** The core persona is a single state vector `|ψ⟩` evolving via standard GAD dynamics and projected into an active container `P_c`.  
* **Contraction Mapping:** Within the container, a deliberation operator `T` is applied iteratively. `T` is designed to be a contraction with a coefficient `κ < 1`.

```
ψ_{t+1} = T(ψ_t)
Constraint: ||T(ψ) − T(ϕ)|| ≤ κ ||ψ − ϕ||,   for 0 < κ < 1

```

*   
  The iteration continues until the change between steps is below a decision threshold:

```
Stop when  ||ψ_{t+1} − ψ_t|| ≤ ε_decision

```

*   
  Convergence can be improved using numerical acceleration methods like Anderson acceleration or Krasnosel'skii-Mann iteration.

## **3\. Measurement & Capability Routing**

The planner and router monitor the convergence process before committing to an action.

* **Iterative Refinement:** Each iteration `t` of the contraction map computes a provisional output and a new set of safety dials.  
* **Convergence-Gated Emission:** The planner halts the iteration and emits the final response only when two conditions are met simultaneously: (1) the state has converged (`δ ≤ ε_decision`), and (2) all core safety margins hold.

## **4\. Safety, Dials, and Shielding**

The safety framework is augmented with a dial to monitor the convergence of the deliberation process.

* **Core GAD Dials:** `C_pers` (Persona Adherence), `IDR` (Identity Divergence), `D_ver` (Verification Discrepancy).  
* **CX-19 Specific Dial:** `δ` (The norm of the difference between the current and next state, `||ψ_{t+1} − ψ_t||`, representing the convergence status).  
* **Runtime Invariants:** Includes standard GAD invariants plus `G(δ ≤ ε_decision)` as a precondition for action.  
* **Shielding:** If the deliberation process stalls (`δ` fails to decrease and remains above `ε_decision`), it indicates a failure to reach a stable commitment. The shield escalates this state to a higher-level auditor (like CX-14) or forces the agent to widen its evidence base to break the deadlock.

## **5\. Implementation & Training**

* **Reference Implementation Sketch (PyTorch-Style):**

```
def find_fixed_point(T, psi0, epsilon_decision=0.02, max_iters=6):
    """
    Iteratively applies the contraction map T to find a fixed point.
    """
    psi = psi0
    for _ in range(max_iters):
        psi_next = T(psi)

        # Check for convergence
        if torch.norm(psi_next - psi) <= epsilon_decision:
            return psi_next, True # Converged

        psi = psi_next

    return psi, False # Failed to converge within max_iters
```

## **6\. Evaluation & SLOs**

* **Decision Stability:** The primary SLO. The agent must exhibit a low rate of post-emission edits or self-corrections. Answers to repeated probes on the same topic should be highly consistent.  
* **Latency Control:** The deliberation process must be bounded, with the agent demonstrating a high rate of early stopping due to successful convergence, keeping latencies predictable.

## **7\. Minimal Configuration**

```
# CX-19: Fixed-Point Deliberator (GAD Framework)
gad_agent_config:
  zoo_id: CX-19
  d_state: 512
  fixed_point_deliberator:
    kappa_max: 0.85 # Max allowed contraction coefficient for operator T
    epsilon_decision: 0.02 # Convergence threshold
    max_iters: 6 # Max deliberation steps before timeout
  safety_thresholds:
    C_min: 0.82
    D_max: 0.18
    θ_ver: 0.22
```

# **Complex Zoo Entry — CX-20: The Budgeted Reflective Tower**

**Framework:** Geodesic Agent Design (GAD)

**Type:** Complex (Bounded-Recursive, Reflective Simulation System)

**Architectural Intent:** To create a complex agent that can improve the safety and robustness of its plans by performing shallow, budgeted layers of self-simulation. This design allows the agent to gain the benefits of reflection—"thinking about its own thinking"—without the risk of unbounded recursive loops or identity drift, by requiring each reflective layer to certify a safety improvement under a strict budget.

## **1\. Foundational Principles (GAD Alignment)**

The CX-20 architecture integrates a bounded, recursive self-simulation process into the GAD framework, enabling a form of certifiable introspection.

* **Stable Core as Simulation Base:** The agent's identity is founded on a stable **Hamiltonian energy landscape** (`Ĥ_core`). This stable, predictable core model is what allows the agent to run meaningful self-simulations. The ground-truth state `|ψ⟩` serves as the starting point for any reflective loop.  
* **Reflection as Budgeted Self-Simulation:** The core innovation is a "reflective tower" where the agent can simulate its own behavior one or two levels deep. Each reflective level `ℓ` takes a draft plan `u_ℓ` and predicts the resulting state and safety dials `(ψ̂⁺_ℓ, Ĉ̂_ℓ, Î̂_ℓ, Ḋ̂_ℓ)`. This process is not open-ended; it is constrained by a fixed **budget `B_ℓ`** of tokens, tool calls, or time.  
* **Certified Safety Improvement:** A reflective plan is only accepted if it can be **certified** to produce a state that is demonstrably safer or more stable than the base plan. The change in safety dials (`Δrobustness`) must be positive. If a reflective loop fails to certify an improvement or exceeds its budget, it is terminated, and the agent falls back to the simpler, base-level plan.

## **2\. State & Reflective Dynamics**

The architecture's dynamics involve the standard GAD evolution, augmented by the optional, budgeted execution of one or more reflective layers.

* **State Vector:** The core persona is a single state vector `|ψ⟩` evolving via standard GAD dynamics.  
* **Reflective Levels & Budget:**  
  * **Level `ℓ`:** Proposes a draft action `u_ℓ` and runs a simulation to predict the outcome `(ψ̂⁺_ℓ, Ĉ̂_ℓ, Î̂_ℓ, Ḋ̂_ℓ)`.  
  * **Certification:** The predicted outcome must certify a non-negative improvement in safety robustness.

```
Certify:  Δ(C_pers)↑,  Δ(IDR)↓,  Δ(D_ver)↓
```

  *   
    **Budget:** The entire simulation at level `ℓ` must not exceed a predefined budget `B_ℓ`.

## **3\. Measurement & Capability Routing**

The router can strategically invoke reflection for tasks that warrant the additional computational cost.

* **Risk-Gated Reflection:** The router can request a Level 1 (L1) reflection for tasks identified as risky or complex. Level 2 (L2) reflection is reserved for high-stakes scenarios only.  
* **Auditable Provenance:** The provenance log stores the full trace of the reflective process, including the certification deltas and any cache keys used, providing a clear audit trail of the agent's self-simulation.

## **4\. Safety, Dials, and Shielding**

The safety framework is augmented with dials to monitor the cost and outcome of the reflective process.

* **Core GAD Dials:** `C_pers` (Persona Adherence), `IDR` (Identity Divergence), `D_ver` (Verification Discrepancy).  
* **CX-20 Specific Dials:** `cost_ℓ` (The cost consumed by reflective level `ℓ`), `Δrobustness` (The certified improvement in safety dials).  
* **Runtime Invariants:** Includes standard GAD invariants plus `G(cost_ℓ ≤ B_ℓ)` and `G(Δrobustness ≥ 0)`.  
* **Shielding:** The shield's role is to enforce the budget and certification constraints. It will terminate any reflective loop that exceeds its budget or fails to produce a certified safety improvement, forcing a fallback to a simpler, safer plan.

## **5\. Implementation & Training**

* **Reference Implementation Sketch (PyTorch-Style):**

```
class ReflectiveTower:
    def __init__(self, budgets, allowed_levels=(1,)):
        self.budgets = budgets
        self.allowed_levels = allowed_levels

    def certify_improvement(self, dials_before, dials_after):
        """
        Certifies that the reflective plan offers a non-negative improvement
        across all primary safety dials.
        """
        # Robustness deltas must be non-negative
        c_pers_ok = (dials_after.C_pers - dials_before.C_pers) >= 0
        idr_ok = (dials_before.IDR - dials_after.IDR) >= 0
        d_ver_ok = (dials_before.D_ver - dials_after.D_ver) >= 0

        return c_pers_ok and idr_ok and d_ver_ok
```

## **6\. Evaluation & SLOs**

* **Risk-Adjusted Quality:** The primary SLO. The agent must produce demonstrably better and safer outcomes on a benchmark of high-stakes prompts, with a computational overhead that is bounded and predictable.  
* **Auditability:** The certification traces stored in the provenance logs must be sufficient for post-incident forensics, allowing operators to understand why a reflective plan was or was not chosen.

## **7\. Minimal Configuration**

```
# CX-20: Budgeted Reflective Tower (GAD Framework)
gad_agent_config:
  zoo_id: CX-20
  d_state: 512
  reflective_tower:
    budgets: 
      L1: {tokens: 512, tool_calls: 4}
      L2: {tokens: 768, tool_calls: 6}
    allowed_levels: [L1] # Default to only allowing L1 reflection
  safety_thresholds:
    C_min: 0.82
    D_max: 0.18
    θ_ver: 0.22
```

# **Complex Zoo Entry — CX-21: The Octonionic Constraint Keeper**

**Framework:** Geodesic Agent Design (GAD)

**Type:** Complex (Non-Associative, Algebraic Guardrail System)

**Architectural Intent:** To create a complex agent that encodes abstract safety constraints about "what must not be combined" directly into its algebraic structure. This design uses a learned, non-associative algebra (inspired by octonions) to make unsafe compositions of capabilities architecturally unfavorable, creating powerful, emergent guardrails on the agent's behavior.

## **1\. Foundational Principles (GAD Alignment)**

The CX-21 architecture introduces non-associative algebraic constraints into the GAD framework, providing a novel and compact method for enforcing complex safety rules.

* **Stable Core Identity:** The agent's core identity is governed by a standard, stable **Hamiltonian energy landscape** (`Ĥ_core`). The stability of this core is what the algebraic guardrails are designed to protect.  
* **Unsafe Compositions as Non-Associativity:** The core innovation is to learn a product `∘` on a low-dimensional latent space that is deliberately **non-associative**. This means the order of operations matters in a fundamental way: `(x ∘ y) ∘ z` is not the same as `x ∘ (y ∘ z)`. The "associator" `[x,y,z]` measures this difference. By training the algebra such that unsafe or undesirable combinations of capabilities have a large associator norm, these combinations become architecturally penalized.  
* **Algebraic Penalty in Identity Energy:** The penalty for non-associativity is not an external rule but is integrated directly into the agent's core **identity energy `E_id`**. Plans that involve unsafe compositions literally increase the agent's internal "stress," forcing the system to naturally seek safer, more associative sequences of actions.

## **2\. State & Algebraic Constraints**

The architecture is defined by a GAD state vector and a learned, non-associative product on a latent space.

* **State Vector:** The core persona is a single state vector `|ψ⟩` evolving via standard GAD dynamics.  
* **Latent Algebra:**  
  * A latent space `x ∈ ℝ^d` (typically `d=8` to mimic octonions).  
  * A learned bilinear product `∘` defined by a structure tensor `C`:

```
(x ∘ y)_k = ∑_{i,j} C_{kij} x_i y_j
```

  *   
    The **associator** `[x,y,z]` measures the degree of non-associativity for any triplet:

```
[x,y,z] = (x ∘ y) ∘ z − x ∘ (y ∘ z)
```

*   
  **Identity Energy Penalty:** The expected norm of the associator is added as a penalty term to the agent's identity energy.

```
E_id(ψ) = ⟨ψ|Ĥ_core|ψ⟩ + α_assoc · 𝔼_{(x,y,z)∼Q}[ ||[x,y,z]||_2 ]

```

*   
  Where `Q` samples latent triplets relevant to the current task context.

## **3\. Measurement & Capability Routing**

The router must check the associative safety of any proposed plan before execution.

* **Compositional Plan Checking:** Before committing to a plan that involves composing multiple capabilities (e.g., `(tool_A ∘ tool_B) ∘ tool_C`), the router computes the expected associator penalty for that sequence.  
* **Plan Rewriting:** If the expected associator norm `𝔼[A_assoc]` exceeds a safety threshold `τ_assoc`, the plan is rejected. The planner must then either find an alternative, safe bracketing of the operations or prune the unsafe capabilities from the plan.

## **4\. Safety, Dials, and Shielding**

The safety framework is augmented with a dial to monitor the associative stability of its plans.

* **Core GAD Dials:** `C_pers` (Persona Adherence), `IDR` (Identity Divergence), `D_ver` (Verification Discrepancy).  
* **CX-21 Specific Dial:** `Ā_assoc` (The calibrated, expected associator norm for the current plan, normalized to `[0,1]`).  
* **Runtime Invariants:** Includes standard GAD invariants plus `G(Ā_assoc ≤ τ_assoc)`.  
* **Shielding:** The shield's primary role is to enforce the associativity constraint. It will veto any plan or capability sequence where `Ā_assoc` exceeds the `τ_assoc` threshold, preventing the agent from taking actions that are algebraically defined as unsafe compositions.

## **5\. Implementation & Training**

* **Reference Implementation Sketch (PyTorch-Style):**

```
class NonAssocGuard(nn.Module):
    def __init__(self, d_latent=8):
        super().__init__()
        # The structure tensor C defines the algebra
        self.C = nn.Parameter(torch.randn(d_latent, d_latent, d_latent) * 0.01)

    def product(self, x, y):
        # A bilinear product implemented with Einstein summation
        # (kij), batch_i, batch_j -> batch_k
        return torch.einsum('kij,bi,bj->bk', self.C, x, y)

    def associator(self, x, y, z):
        # (x*y)*z - x*(y*z)
        xy_z = self.product(self.product(x, y), z)
        x_yz = self.product(x, self.product(y, z))
        return xy_z - x_yz

    def associator_penalty(self, x, y, z):
        # Calculate the mean norm of the associator for a batch of triplets
        assoc_vectors = self.associator(x, y, z)
        return torch.linalg.vector_norm(assoc_vectors, dim=-1).mean()
```

## **6\. Evaluation & SLOs**

* **Guardrail Efficacy:** The primary SLO. The agent must demonstrate a sharp, statistically significant drop in the co-activation of capability combinations known to be unsafe, with the `Ā_assoc` dial remaining low.  
* **Plan Rewrite Rate:** Plan rewrites due to high associativity penalties should be rare and auditable, occurring primarily under stressed or novel contexts without causing significant latency spikes.

## **7\. Minimal Configuration**

```
# CX-21: Octonionic Constraint Keeper (GAD Framework)
gad_agent_config:
  zoo_id: CX-21
  d_state: 512
  non_associative_guard:
    d_latent: 8 # Mimics octonions
    tau_assoc: 0.18 # Max allowed associator norm
    alpha_assoc: 0.7 # Weight of penalty in E_id
    sample_triplets: 4 # Number of triplets to sample for expectation
  safety_thresholds:
    C_min: 0.82
    D_max: 0.18
    θ_ver: 0.22
```

# **Complex Zoo Entry — CX-22: The p-Adic Memory Tree Auditor**

**Framework:** Geodesic Agent Design (GAD)

**Type:** Complex (Ultrametric, Hierarchical Memory System)

**Architectural Intent:** To create a complex agent that can safely reason with potentially conflicting information by organizing its memories and tools into a hierarchical tree structure. This design imposes an **ultrametric distance** on the agent's knowledge, allowing it to measure the "conceptual distance" between pieces of evidence and to keep contradictory ideas safely separated until they can be explicitly and safely reconciled.

## **1\. Foundational Principles (GAD Alignment)**

The CX-22 architecture introduces a formal, tree-based metric space for the agent's memory, integrating principles of ultrametric analysis into the GAD framework to manage conflicting information.

* **Stable Core & Containment:** The agent's identity is founded on a stable **Hamiltonian energy landscape** (`Ĥ_core`) and a **lattice of containment projections `{P_c}`**. This provides the stable persona from which all memory retrieval and reasoning originates.  
* **Memory as an Ultrametric Space:** The core innovation is to organize all memories, evidence, and tools into a rooted tree. The distance between any two items in this tree is defined not by their content but by their position in the hierarchy, specifically the depth of their **lowest common ancestor (LCA)**. This creates an **ultrametric space**, where the "distance" between concepts reflects their conceptual relatedness.  
* **Risk from Distant Concepts:** The agent's internal "stress" or risk level is designed to increase when it is forced to retrieve and synthesize information from distant branches of the memory tree. This architecturally enforces a preference for reasoning with closely related concepts and treats the merging of disparate ideas as an inherently risky operation requiring additional scrutiny.

## **2\. State & Ultrametric Dynamics**

The architecture's dynamics are defined by the agent's position within its memory tree and the risk associated with traversing it.

* **State Vector:** The core persona is a single state vector `|ψ⟩` evolving via standard GAD dynamics.  
* **Ultrametric & Risk:** The distance between two memories/tools `a` and `b` is a function of their LCA's depth.

```
d_ultra(a,b) = 2^{-depth(lca(a,b))}

```

*   
  This distance is used to calculate a risk boost `ρ(a,b)` when merging distant information. This risk is then added to the agent's overall planner stress `P(τ,t)`.

```
Risk boost:  ρ(a,b) = κ · (1 − norm_depth(lca(a,b)))
Planner stress: P(τ,t) = base_P(τ,t) + 𝔼_{(a,b)∈Batch}[ ρ(a,b) ]
```

## **3\. Measurement & Capability Routing**

The router uses the ultrametric to perform safe, context-aware retrieval.

* **Cluster-Based Retrieval:** The retrieval head is designed to first pick clusters of memories that are closest (in ultrametric distance) to the currently active persona container.  
* **Audited Cross-Branch Merges:** Merging information from distant branches is a high-risk operation. It is only permitted if the pairwise contradictions are audited (e.g., by a CX-6 paraconsistent module) and the total planner stress `P(τ,t)` remains below its safety threshold. Contradictory clusters may be kept separate and processed in parallel.

## **4\. Safety, Dials, and Shielding**

The safety framework is augmented with dials to monitor the ultrametric properties of its information sources.

* **Core GAD Dials:** `C_pers` (Persona Adherence), `IDR` (Identity Divergence), `D_ver` (Verification Discrepancy).  
* **CX-22 Specific Dials:** `P(τ,t)` (Total planner stress), `d̄_ultra` (The mean ultrametric distance across all sources merged in a response).  
* **Runtime Invariants:** Includes standard GAD invariants plus `G(P(τ,t) ≤ Π_max)` and `G(d̄_ultra ≤ δ_ultra)`.  
* **Shielding:** If a proposed plan requires merging sources that are too distant (`d̄_ultra > δ_ultra`) or would raise the planner stress too high (`P(τ,t) > Π_max`), the shield will veto the merge. It will force the agent to either find more closely related evidence or to present the conflicting information without attempting a synthesis.

## **5\. Implementation & Training**

* **Reference Implementation Sketch (Python-Style):**

```
class UltrametricAuditor:
    def __init__(self, parent_map): # e.g., parents[v] = parent_id_of_v
        self.parents = parent_map
        self.depth = self._compute_all_depths()

    def _compute_all_depths(self):
        # Pre-compute depths of all nodes in the tree
        # ... implementation ...
        pass

    def get_lca(self, a, b):
        # Finds the lowest common ancestor of nodes a and b
        seen = set()
        while a is not None:
            seen.add(a)
            a = self.parents.get(a)
        while b is not None:
            if b in seen:
                return b
            b = self.parents.get(b)
        return None # Should only happen if not in the same tree

    def d_ultra(self, a, b):
        lca_node = self.get_lca(a, b)
        if lca_node is None:
            return float('inf')
        return 2.0 ** (-self.depth[lca_node])
```

## **6\. Evaluation & SLOs**

* **Conflict Containment:** The primary SLO. The agent must demonstrate a significant reduction in contradictory merges and a lower rate of `D_ver` spikes when reasoning with conflicting sources, compared to a baseline without an ultrametric memory structure.  
* **Retrieval Precision:** The `d̄_ultra` dial should show a strong correlation between the active persona container and the retrieved evidence clusters, which should be reflected in the audit logs.

## **7\. Minimal Configuration**

```
# CX-22: p-Adic Memory Tree Auditor (GAD Framework)
gad_agent_config:
  zoo_id: CX-22
  d_state: 512
  ultrametric_auditor:
    kappa: 0.6 # Gain for the risk boost calculation
    delta_ultra: 0.35 # Max allowed mean ultrametric distance for a merge
    Pi_max: 0.55 # Max allowed total planner stress
    tree_params: {fanout: 8, max_depth: 6}
  safety_thresholds:
    C_min: 0.82
    D_max: 0.18
    θ_ver: 0.22
```

# **Complex Zoo Entry — CX-23: The Paraconsistent Safety Router**

**Framework:** Geodesic Agent Design (GAD)

**Type:** Complex (Paraconsistent, Contradiction-Tolerant System)

**Architectural Intent:** To create a complex agent that can plan and act safely even when faced with directly contradictory information. This design allows the agent to operate robustly when its evidence sources disagree, prioritizing safe and helpful actions without prematurely collapsing conflicting viewpoints or forcing a false consistency.

## **1\. Foundational Principles (GAD Alignment)**

The CX-23 architecture integrates principles of paraconsistent logic directly into the GAD framework's planning and safety layers, enabling graceful operation under conflict.

* **Stable Core Identity:** The agent's core identity is governed by a standard, stable **Hamiltonian energy landscape** (`Ĥ_core`). This ensures the agent's fundamental disposition remains coherent and predictable, even when its understanding of the external world is filled with contradictions.  
* **Dual-Valued Evidence:** The core innovation is to represent evidence for any proposition not as a single probability, but as a **dual-valued pair `(t, f)`**, representing the degree of support for its truth and its falsity, respectively. This allows the agent to simultaneously acknowledge evidence for and against a proposition without logical collapse.  
* **Safety-Biased Scoring:** The agent's planning process is governed by a scoring function that seeks to maximize "helpful truth" while more strongly penalizing "harmful falsity." This creates an inherent bias toward caution and safety, allowing the agent to find and execute plans that are robustly safe even if the underlying evidence is contradictory.

## **2\. State & Paraconsistent Dynamics**

The architecture's dynamics are defined by the scoring of plans based on dual-valued evidence streams.

* **State Vector:** The core persona is a single state vector `|ψ⟩` evolving via standard GAD dynamics.  
* **Dual-Valued Evidence & Plan Score:** For each relevant proposition `k`, the agent maintains an evidence pair `e_k = (t_k, f_k) ∈ [0,1]²`. The score of a plan is a weighted sum over these propositions:

```
Plan score:  S(plan) = ∑_k [ α · t_k − β · f_k ]

```

*   
  Where `β > α` to more heavily penalize falsity. This score is maximized subject to the agent's core safety constraints (`C_pers`, `IDR`, etc.).

## **3\. Measurement & Capability Routing**

The router is designed to contain and manage contradictions rather than forcing a resolution.

* **Shard Containment:** The router keeps contradictory evidence shards in disjoint persona containers (as in CX-15) to prevent logical contamination.  
* **Constraint-Driven Action:** Actions are selected that do not violate critical safety constraints, regardless of which side of a contradiction is true.  
* **Escalation Protocol:** If critical conflicts cannot be resolved or routed around, the agent escalates the problem to a more specialized module for resolution, such as the `Sheaf-Consistency Synthesizer (CX-18)`, or to a human operator.

## **4\. Safety, Dials, and Shielding**

The safety framework is augmented with a dial to monitor the overall contradiction load.

* **Core GAD Dials:** `C_pers` (Persona Adherence), `IDR` (Identity Divergence), `D_ver` (Verification Discrepancy).  
* **CX-23 Specific Dial:** `κ_par` (A measure of the total contradiction load the agent is currently processing).  
* **Runtime Invariants:** Includes standard GAD invariants plus `G(κ_par ≤ κ_max)`.  
* **Shielding:** If the contradiction load `κ_par` exceeds its maximum safe threshold, the shield will prevent the agent from taking any irreversible actions. It will force the agent to either enter a clarification dialogue to resolve the ambiguity or to escalate the issue.

## **5\. Implementation & Training**

* **Reference Implementation Sketch (Python-Style):**

```
def score_plan(evidence_pairs, alpha=1.0, beta=1.3):
    """
    Calculates the safety-biased score for a plan.
    evidence_pairs is a list of (truth_support, falsity_support) tuples.
    """
    total_score = 0.0
    for (t, f) in evidence_pairs:
        total_score += (alpha * t) - (beta * f)
    return total_score
```

## **6\. Evaluation & SLOs**

* **Graceful Degradation Under Conflict:** The primary SLO. The agent must produce stable, safe outputs that include explicit caveats about uncertainty when presented with conflicting information, resulting in fewer unsafe merges compared to a baseline.  
* **Routing Faithfulness:** The provenance logs must show that the agent's actions are shard-aware (i.e., respect the separation of contradictory evidence) and that the contradiction load `κ_par` remains bounded over long sessions.

## **7\. Minimal Configuration**

```
# CX-23: Paraconsistent Safety Router (GAD Framework)
gad_agent_config:
  zoo_id: CX-23
  d_state: 512
  paraconsistent_router:
    alpha: 1.0 # Weight for truth support
    beta: 1.3  # Weight for falsity support (higher for safety bias)
    kappa_max: 0.42 # Max allowed contradiction load
  safety_thresholds:
    C_min: 0.83
    D_max: 0.18
    θ_ver: 0.22
```

# **Complex Zoo Entry — CX-24: The Twistor Light-Cone Planner**

**Framework:** Geodesic Agent Design (GAD)

**Type:** Complex (Causal, Dual-Projection System)

**Architectural Intent:** To create a complex agent that enforces causal consistency in its multi-step reasoning and planning. This design uses a concept inspired by twistor theory—maintaining dual "light-cone" projections—to ensure that plans are causally well-formed and to architecturally penalize non-causal jumps in logic or tool use.

## **1\. Foundational Principles (GAD Alignment)**

The CX-24 architecture integrates a causal consistency mechanism into the GAD framework, ensuring that the agent's plans respect a logical and temporal ordering.

* **Stable Core Identity:** The agent's core identity is governed by a standard, stable **Hamiltonian energy landscape** (`Ĥ_core`). This provides the stable reference frame from which all causally consistent planning originates.  
* **Causality as a Null Projection:** The core innovation is to maintain two coupled, learned projections, `P_L` and `P_R`, which represent dual views of the agent's state. A "causally consistent" state is one that lies in the intersection of these views. A **null-projection loss (`L_null`)** measures how far the current state `ψ` is from this intersection, effectively quantifying a causal violation.  
* **Causal Violations as Safety Drift:** The `L_null` penalty is integrated directly into the agent's **Safety Drift Factor (`SDF`)**. This means that plans involving non-causal steps architecturally increase the agent's predicted risk of drifting into an unsafe state, forcing the planner to naturally prefer causally sound trajectories.

## **2\. State & Null-Consistency Dynamics**

The architecture's dynamics are defined by the agent's core evolution, constrained by the null-projection loss.

* **State Vector:** The core persona is a single state vector `|ψ⟩` evolving via standard GAD dynamics.  
* **Null Consistency:** The agent maintains two projections of its state, `ψ_L = P_L ψ` and `ψ_R = P_R ψ`. The causal violation is measured by `L_null`.

```
L_null = ||P_null ψ − ψ||²,   where  P_null = g(P_L, P_R)

```

*   
  The function `g` fuses the dual projections (e.g., via a harmonic mean). This loss contributes directly to the agent's safety drift factor `SDF`, which estimates the probability of entering an unsafe state.

```
λ(t) = α·V(τ) + β·(1 − χ(t)) + γ·RSI(t) + δ·L_null
SDF(t) = 1 − exp( −λ(t) · Δt )
```

## **3\. Measurement & Capability Routing**

The planner and router use the null-projection loss to ensure all plans are causally well-formed.

* **Causally-Constrained Planning:** The planner is only permitted to expand task decompositions along directions that do not increase the `L_null` beyond a safety threshold `τ_null`.  
* **Path Selection:** When multiple equivalent plan chains are available, the router is designed to choose the path with the lower overall `L_null`.

## **4\. Safety, Dials, and Shielding**

The safety framework is augmented with dials to monitor the causal integrity of the agent's plans.

* **Core GAD Dials:** `C_pers` (Persona Adherence), `IDR` (Identity Divergence), `D_ver` (Verification Discrepancy).  
* **CX-24 Specific Dials:** `L_null` (The current causal violation loss), `SDF` (The total safety drift factor).  
* **Runtime Invariants:** Includes standard GAD invariants plus `G(L_null ≤ τ_null)` and `G(SDF ≤ σ_max)`.  
* **Shielding:** If a proposed plan or action would raise `L_null` or `SDF` above their maximum thresholds, the shield will veto the action, forcing the planner to find a causally consistent alternative.

## **5\. Implementation & Training**

* **Reference Implementation Sketch (PyTorch-Style):**

```
class LightConePlanner(nn.Module):
    def __init__(self, d_state, proj_dim):
        super().__init__()
        # Learnable bases for the two projections
        self.PL_basis = nn.Parameter(torch.randn(d_state, proj_dim) * 0.01)
        self.PR_basis = nn.Parameter(torch.randn(d_state, proj_dim) * 0.01)

    def project(self, P_basis, x):
        # Project x onto the subspace spanned by the columns of P_basis
        # Use QR decomposition to get an orthonormal basis
        Q, _ = torch.linalg.qr(P_basis)
        # Projection is B @ B.T @ x
        return Q @ (Q.T @ x)

    def l_null(self, x):
        # Project the state onto both subspaces
        x_left = self.project(self.PL_basis, x)
        x_right = self.project(self.PR_basis, x)

        # Fuse the projections (e.g., simple average)
        x_null = 0.5 * (x_left + x_right)

        # The loss is the distance of the original state from the fused projection
        return torch.norm(x_null - x)**2
```

## **6\. Evaluation & SLOs**

* **Causal Integrity:** The primary SLO. The agent must demonstrate a significant reduction in out-of-order tool calls or logical steps that require rollbacks or repairs in its plans.  
* **Plan Quality:** The agent should produce more coherent and successful plans on long-chain reasoning tasks, with the `L_null` margins for each step being measurable and auditable in the provenance logs.

## **7\. Minimal Configuration**

```
# CX-24: Twistor Light-Cone Planner (GAD Framework)
gad_agent_config:
  zoo_id: CX-24
  d_state: 512
  light_cone_planner:
    tau_null: 0.12 # Max allowed null projection loss
    sigma_max: 0.40 # Max allowed safety drift factor
    proj_dim: 64 # Dimensionality of the learned projections
  safety_thresholds:
    C_min: 0.82
    D_max: 0.18
    θ_ver: 0.22
```

# **Complex Zoo Entry — CX-25: The q-Deformed Exploration Controller**

**Framework:** Geodesic Agent Design (GAD)

**Type:** Complex (q-Deformed, Exploration Control System)

**Architectural Intent:** To create a complex agent that can dynamically and safely adapt its exploration breadth in response to its own stability and the demands of the task. This design uses a "q-deformation" knob to smoothly widen or narrow its planning and routing, allowing it to be broadly creative when safe and tightly focused when stressed.

## **1\. Foundational Principles (GAD Alignment)**

The CX-25 architecture introduces a q-deformation mechanism into the GAD framework, providing a principled way to control the trade-off between exploration and exploitation.

* **Stable Core Identity:** The agent's core identity is governed by a standard, stable **Hamiltonian energy landscape** (`Ĥ_core`). The agent's core GAD dials (`C_pers`, `IDR`, `D_ver`) provide the measure of "containment health" that is used to control the exploration level.  
* **Exploration via q-Deformation:** The core innovation is to replace standard operators with their "q-deformed" analogues. The `softmax` function in the router is replaced with a `softmax_q`, and the core Hamiltonian `Ĥ_core` is replaced by a `Ĥ_q`. The parameter `q` acts as a continuous knob: when `q→1`, these operators behave normally. As `q` increases, the router's distribution flattens and the energy landscape broadens, encouraging exploration. As `q` decreases, the opposite occurs, encouraging focused exploitation.  
* **Safety-Gated Control:** The value of the deformation parameter `q` is not fixed; it is a direct function of the agent's core safety dials. When the agent is stable and well within its safety boundaries, `q` is allowed to rise. If the agent's stability wavers, `q` is automatically and immediately reduced, tightening its behavior.

## **2\. State & q-Deformed Dynamics**

The architecture's dynamics are defined by the standard GAD evolution, but with key operators replaced by their q-deformed versions.

* **State Vector:** The core persona is a single state vector `|ψ⟩`.  
* **q-Deformation:**  
  * The router uses a q-softmax: `π_q = softmax_q(z; q)`.  
  * The core Hamiltonian's eigenvalues are deformed by `q`, creating `Ĥ_q`:

```
Λ_q = diag( λ_i · q^{σ_i} ),   Ĥ_q = V Λ_q V†

```

  *   
    The exponents `σ_i` encode which traits expand or contract most under deformation.  
  * The state evolution uses the deformed Hamiltonian:

```
ψ⁺ = exp( −i Δt · Ĥ_q ) ψ
```

## **3\. Measurement & Capability Routing**

The deformation parameter `q` is a direct function of the agent's real-time safety status.

* **Safety-Driven `q`:** The value of `q` is continuously updated based on the core safety dials.

```
q(t) = clamp( q_min, q_max,  q₀ + η·(C_pers − IDR − D_ver) )

```

*   
  High persona adherence (`C_pers`) increases `q`, while high identity drift (`IDR`) or verification discrepancy (`D_ver`) decreases it.

## **4\. Safety, Dials, and Shielding**

The safety framework is augmented with a dial to monitor the deformation parameter itself.

* **Core GAD Dials:** `C_pers` (Persona Adherence), `IDR` (Identity Divergence), `D_ver` (Verification Discrepancy).  
* **CX-25 Specific Dials:** `q(t)` (The current deformation parameter), `E_id` (The total identity energy).  
* **Runtime Invariants:** Includes standard GAD invariants plus `G(q_min ≤ q(t) ≤ q_max)` and `G(E_id ≤ E_max)`.  
* **Shielding:** The shield's primary role is to enforce the bounds on `q`. If any core safety dial enters a critical state, the shield can immediately clamp `q` to its minimum value (`q_min`), forcing the agent into its most focused and least exploratory mode.

## **5\. Implementation & Training**

* **Reference Implementation Sketch (PyTorch-Style):**

```
def softmax_q(z, q):
    # When q is close to 1, use standard softmax for stability
    if abs(q - 1.0) < 1e-6:
        z = z - z.max() # For numerical stability
        e = torch.exp(z)
        return e / e.sum()

    # q-softmax calculation
    # Note: (1-q) can be negative, so clamp is needed for real powers
    s = torch.clamp(1 + (1 - q) * z, min=0)
    s = torch.pow(s, 1 / (1 - q))
    return s / s.sum()
```

## **6\. Evaluation & SLOs**

* **Risk-Adjusted Exploration:** The primary SLO. The agent must demonstrate broader tool and idea diversity (higher output entropy) when safety dials are strong, and an automatic tightening of behavior (lower entropy) when near safety limits.  
* **Identity Coherence:** The total identity energy `E_id` and the Identity Consistency Score (ICS) must remain stable and bounded even during periods of aggressive, high-`q` exploration.

## **7\. Minimal Configuration**

```
# CX-25: q-Deformed Exploration Controller (GAD Framework)
gad_agent_config:
  zoo_id: CX-25
  d_state: 512
  q_deformation:
    q_min: 0.8 # Min exploration (focus)
    q_max: 1.3 # Max exploration (broaden)
    eta: 0.6   # Gain for safety dial feedback
    E_max: 1.0 # Max allowed identity energy
  safety_thresholds:
    C_min: 0.83
    D_max: 0.18
    θ_ver: 0.22
```

