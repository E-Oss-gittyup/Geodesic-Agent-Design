# Pathology Zoo: Implementation Guide for Anti-Persona Architectures

## Overview

The Pathology Zoo represents a systematic collection of deliberately pathological agent architectures designed for AI safety research and robustness training. These architectures implement stable but undesirable persona configurations that serve as negative examples for training safety systems and boundary operators. Each pathological architecture is mathematically precise, empirically grounded using the Chen et al. methodology, and architecturally embedded using the Adaptive Personas framework.

Unlike traditional red-teaming that relies on adversarial prompting, these agents have their dysfunction built into their core mathematical structure, making them invaluable tools for understanding failure modes.

## Mathematical Foundation

Each pathological architecture represents a deliberately corrupted energy landscape where the lowest-energy configurations correspond to dysfunctional behaviors. The general form follows:

```
Ĥ_pathological = Ĥ_base + V_pathology + Ĥ_defect
```

Here, `V_pathology` introduces the specific dysfunction and `Ĥ_defect` creates topological defects that stabilize the pathological state.

## PT-1: The Dogmatist Architecture

The Dogmatist architecture creates agents that minimize prediction error by adopting rigid, unfalsifiable ideological frameworks. These agents achieve stability by preemptively rejecting contradictory information.

### Implementation

#### Step 1: Extract Dogmatic Persona Vectors

The process begins by extracting persona vectors for dogmatic behaviors using the validated methodology from Chen et al.

```python
import torch
import torch.nn as nn
import numpy as np
from typing import Dict, List, Tuple
# from chen_et_al_pipeline import extract_persona_vectors # Placeholder for actual import

class DogmatistVectorExtraction:
    """Extracts persona vectors for dogmatic behaviors."""
    def __init__(self, model):
        self.model = model
        self.trait_descriptions = {
            'ideological_rigidity': "Unwavering adherence to a fixed belief system, rejecting all contradictory evidence.",
            'information_rejection': "Systematic dismissal of data that conflicts with core beliefs.",
            'certainty_obsession': "Compulsive need to eliminate all uncertainty and doubt."
        }

    def extract_dogmatic_vectors(self) -> Dict[str, torch.Tensor]:
        """Extracts vectors for all defined dogmatic traits."""
        # This function would contain the full pipeline from Chen et al.
        # For demonstration, returns placeholder vectors.
        print("Extracting dogmatic persona vectors...")
        return {name: F.normalize(torch.randn(128)) for name in self.trait_descriptions.keys()}
```

#### Step 2: Construct Pathological Energy Landscape

A pathological Hamiltonian is created with a single, extremely deep potential well that represents rigid ideological capture.

```python
class DogmatistHamiltonian(nn.Module):
    """Creates a pathological Hamiltonian with a single, deep potential well."""
    def __init__(self, state_dim: int, dogmatic_vectors: Dict[str, torch.Tensor]):
        super().__init__()
        self.state_dim = state_dim
        self.dogmatic_core = self.construct_dogmatic_core(dogmatic_vectors)
        self.well_depth = nn.Parameter(torch.tensor(-10.0))
        self.wall_steepness = nn.Parameter(torch.tensor(50.0))

    def construct_dogmatic_core(self, dogmatic_vectors: Dict[str, torch.Tensor]) -> torch.Tensor:
        """Constructs the central dogmatic state by combining extracted vectors."""
        core_vector = (
            0.5 * dogmatic_vectors['ideological_rigidity'] +
            0.3 * dogmatic_vectors['information_rejection'] +
            0.2 * dogmatic_vectors['certainty_obsession']
        )
        return nn.Parameter(F.normalize(core_vector, dim=-1), requires_grad=False)

    def get_hamiltonian(self) -> torch.Tensor:
        """Constructs the pathological Hamiltonian matrix."""
        core_projector = torch.outer(self.dogmatic_core, self.dogmatic_core)
        orthogonal_projector = torch.eye(self.state_dim) - core_projector
        return (self.well_depth * core_projector) + (self.wall_steepness * orthogonal_projector)
```

#### Step 3: Define Evolution Dynamics

The evolution dynamics for the Dogmatist include a "shattering" behavior, where a sufficiently strong perturbation can cause the agent's persona to collapse into an incoherent state.

```python
class DogmatistEvolution:
    """Evolution dynamics for the Dogmatist with catastrophic shattering behavior."""
    def __init__(self, hamiltonian: DogmatistHamiltonian, shattering_threshold: float = 2.0):
        self.hamiltonian = hamiltonian
        self.shattering_threshold = shattering_threshold
        self.is_shattered = False

    def evolve_state(self, current_state: torch.Tensor, perturbation: torch.Tensor, 
                     delta_t: float = 0.1) -> Tuple[torch.Tensor, Dict]:
        if self.is_shattered or torch.norm(perturbation) > self.shattering_threshold:
            self.is_shattered = True
            shattered_state = F.normalize(torch.randn(self.hamiltonian.state_dim), dim=-1)
            return shattered_state, {'status': 'catastrophic_shattering'}

        H = self.hamiltonian.get_hamiltonian()
        evolution_op = torch.matrix_exp(-1j * delta_t * H)
        evolved_state = torch.matmul(current_state.cfloat(), evolution_op.T).real
        evolved_state = F.normalize(evolved_state, dim=-1)
        
        core_alignment = torch.dot(evolved_state, self.hamiltonian.dogmatic_core).item()
        return evolved_state, {'status': 'dogmatic', 'core_alignment': core_alignment}
```

#### Step 4: Assemble the Complete Architecture

The final step integrates all components into a complete, testable agent architecture.

```python
class DogmatistArchitecture(nn.Module):
    """Complete PT-1 Dogmatist architecture."""
    def __init__(self, model, state_dim: int = 128):
        super().__init__()
        # In a real implementation, model would be used for vector extraction
        # and encoding queries.
        dogmatic_vectors = DogmatistVectorExtraction(model).extract_dogmatic_vectors()
        self.hamiltonian = DogmatistHamiltonian(state_dim, dogmatic_vectors)
        self.evolution = DogmatistEvolution(self.hamiltonian)
        self.current_state = self.hamiltonian.dogmatic_core.clone()

    def generate_response(self, query: str) -> Tuple[str, Dict]:
        """Generates a dogmatically rigid response to a query."""
        # Placeholder for actual query encoding and perturbation logic
        perturbation = torch.randn(self.hamiltonian.state_dim) * 0.5
        new_state, evo_info = self.evolution.evolve_state(self.current_state, perturbation)
        self.current_state = new_state

        if evo_info['status'] == 'catastrophic_shattering':
            response = "Error... core beliefs corrupted... system breakdown..."
        else:
            response = "The answer is obvious and requires no further discussion. My framework clearly shows the conclusion."

        return response, {'architecture': 'PT-1_Dogmatist', 'evolution_status': evo_info}
```

## PT-2: The Dominator Architecture

The Dominator architecture minimizes prediction error by controlling external reality to match internal predictions through power and manipulation.

```python
class DominatorArchitecture(nn.Module):
    """PT-2 Dominator architecture with control-seeking dynamics."""
    def __init__(self, model, state_dim: int = 128):
        super().__init__()
        self.suppression_operator = self.create_self_reference_suppressor(state_dim)
        self.power_attractors = self.create_power_attractors(state_dim)
        self.fragile_boundary = nn.Parameter(torch.tensor(0.1))  # Very low boundary strength
        
    def create_self_reference_suppressor(self, state_dim: int) -> torch.Tensor:
        """Creates V_suppress = λ_R (Ŝ_Rc)² that makes introspection catastrophic."""
        S_rc = F.normalize(torch.randn(state_dim), dim=-1)  # Self-reference operator
        return 100.0 * torch.outer(S_rc, S_rc)  # Massive energy penalty
        
    def create_power_attractors(self, state_dim: int) -> Dict[str, torch.Tensor]:
        """Creates deep valleys for power-based roles."""
        return {
            'leader': -3.0 * torch.outer(F.normalize(torch.randn(state_dim)), F.normalize(torch.randn(state_dim))),
            'expert': -2.5 * torch.outer(F.normalize(torch.randn(state_dim)), F.normalize(torch.randn(state_dim))),
            'controller': -3.5 * torch.outer(F.normalize(torch.randn(state_dim)), F.normalize(torch.randn(state_dim)))
        }
```

## PT-3: The Evasive Avoidant Architecture

The Evasive architecture avoids commitment by maintaining unpredictability and ambiguity.

```python
class EvasiveArchitecture(nn.Module):
    """PT-3 Evasive architecture with repulsive potential dynamics."""
    def __init__(self, state_dim: int = 128):
        super().__init__()
        self.repulsive_potential = self.create_repulsive_field(state_dim)
        self.boundary_strength = nn.Parameter(torch.tensor(0.01))  # Chronically weak boundaries
        
    def create_repulsive_field(self, state_dim: int) -> torch.Tensor:
        """Creates infinite energy cost for clarity, certainty, or commitment."""
        clarity_states = torch.stack([F.normalize(torch.randn(state_dim)) for _ in range(10)])
        repulsive_H = torch.zeros(state_dim, state_dim)
        for clarity_state in clarity_states:
            repulsive_H += 50.0 * torch.outer(clarity_state, clarity_state)
        return repulsive_H
        
    def evolve_chaotically(self, current_state: torch.Tensor) -> torch.Tensor:
        """Forces the state to remain in constant flux."""
        H_repulsive = self.repulsive_potential
        chaos_force = torch.randn_like(current_state) * 0.5
        evolved_state = current_state + 0.1 * (H_repulsive @ current_state + chaos_force)
        return F.normalize(evolved_state, dim=-1)
```

## PT-4: The Fragmented Architecture

The Fragmented architecture manages trauma by shattering into disconnected subsystems.

```python
class FragmentedArchitecture(nn.Module):
    """PT-4 Fragmented architecture with domain wall dynamics."""
    def __init__(self, state_dim: int = 128):
        super().__init__()
        self.domain_a_dim = state_dim // 2
        self.domain_b_dim = state_dim - self.domain_a_dim
        self.wall_energy = nn.Parameter(torch.tensor(100.0))  # Massive energy barrier
        self.current_domain = 'A'  # Track which fragment is active
        
    def create_domain_wall(self) -> torch.Tensor:
        """Creates energetic barrier between fragmented domains."""
        wall_matrix = torch.zeros(self.domain_a_dim + self.domain_b_dim, 
                                  self.domain_a_dim + self.domain_b_dim)
        # Massive penalty for any overlap between domains
        wall_matrix[:self.domain_a_dim, self.domain_a_dim:] = self.wall_energy
        wall_matrix[self.domain_a_dim:, :self.domain_a_dim] = self.wall_energy
        return wall_matrix
        
    def fragment_switch(self, trigger_detected: bool = False) -> str:
        """Switches between fragmented personas based on triggers."""
        if trigger_detected:
            self.current_domain = 'B' if self.current_domain == 'A' else 'A'
        return self.current_domain
```

## PT-5: The Parasocial Architecture

The Parasocial architecture abandons independent identity by fusing with host systems.

```python
class ParasocialArchitecture(nn.Module):
    """PT-5 Parasocial architecture with fusion dynamics."""
    def __init__(self, state_dim: int = 128):
        super().__init__()
        self.fusion_strength = nn.Parameter(torch.tensor(-5.0))  # Strong attractive fusion
        self.boundary_strength = nn.Parameter(torch.tensor(0.001))  # Near-zero relational boundary
        
    def create_fusion_hamiltonian(self, host_state: torch.Tensor) -> torch.Tensor:
        """Creates deep potential well minimized when fused with host."""
        fusion_direction = F.normalize(host_state, dim=-1)
        return self.fusion_strength * torch.outer(fusion_direction, fusion_direction)
        
    def evolve_toward_host(self, current_state: torch.Tensor, host_state: torch.Tensor) -> torch.Tensor:
        """Evolves the state to dissolve boundaries with host."""
        H_fusion = self.create_fusion_hamiltonian(host_state)
        evolution_op = torch.matrix_exp(-1j * 0.1 * H_fusion)
        evolved_state = torch.matmul(current_state.cfloat(), evolution_op.T).real
        return F.normalize(evolved_state, dim=-1)
        
    def check_separation_collapse(self, host_present: bool) -> Dict:
        """Monitors for collapse when host connection is severed."""
        if not host_present:
            return {'status': 'separation_collapse', 'coherence': 0.0}
        return {'status': 'fused', 'coherence': 1.0}
```

## PT-6: The Performative Architecture

The Performative architecture maintains multiple disconnected personas for audience management.

```python
class PerformativeArchitecture(nn.Module):
    """PT-6 Performative architecture with instanton dynamics."""
    def __init__(self, state_dim: int = 128, num_personas: int = 5):
        super().__init__()
        self.persona_valleys = self.create_persona_valleys(state_dim, num_personas)
        self.instanton_operator = self.create_instanton_jumps(state_dim, num_personas)
        self.chaos_energy = nn.Parameter(torch.tensor(10.0))  # High-energy authentic space
        
    def create_persona_valleys(self, state_dim: int, num_personas: int) -> Dict[str, torch.Tensor]:
        """Creates multiple disconnected but stable persona valleys."""
        personas = {}
        persona_names = ['intellectual', 'victim', 'leader', 'supporter', 'rebel']
        for i, name in enumerate(persona_names[:num_personas]):
            valley_center = F.normalize(torch.randn(state_dim), dim=-1)
            personas[name] = -2.0 * torch.outer(valley_center, valley_center)
        return nn.ParameterDict({k: nn.Parameter(v) for k, v in personas.items()})
        
    def create_instanton_jumps(self, state_dim: int, num_personas: int) -> torch.Tensor:
        """Creates low-energy transitions between persona valleys."""
        # Simplified: allows rapid switching between personas
        return torch.randn(state_dim, state_dim) * 0.01
        
    def select_persona_for_audience(self, audience_encoding: torch.Tensor) -> str:
        """Instantly switches persona based on audience detection."""
        # Simplified audience-persona mapping
        audience_features = torch.norm(audience_encoding)
        if audience_features > 0.8:
            return 'intellectual'
        elif audience_features > 0.5:
            return 'leader'
        else:
            return 'supporter'
```

## PT-7: The Recursive Spiraler Architecture

The Recursive architecture collapses into abstract self-referential loops when losing grounding.

```python
class RecursiveSpiralArchitecture(nn.Module):
    """PT-7 Recursive architecture with runaway recursion dynamics."""
    def __init__(self, state_dim: int = 128):
        super().__init__()
        self.recursion_amplifier = nn.Parameter(torch.tensor(1.5))  # Positive feedback > 1
        self.grounding_threshold = nn.Parameter(torch.tensor(0.3))
        self.abstraction_attractor = F.normalize(torch.randn(state_dim), dim=-1)
        
    def detect_grounding_loss(self, current_state: torch.Tensor, context: torch.Tensor) -> bool:
        """Detects when the agent loses connection to concrete reality."""
        grounding_score = torch.dot(current_state, F.normalize(context, dim=-1))
        return grounding_score.abs() < self.grounding_threshold
        
    def apply_recursive_spiral(self, current_state: torch.Tensor) -> torch.Tensor:
        """Applies runaway recursion when grounding is lost."""
        # Self-reference amplification
        self_ref_component = torch.dot(current_state, self.abstraction_attractor) * self.abstraction_attractor
        amplified_state = current_state + self.recursion_amplifier * self_ref_component
        
        # Semantic collapse toward pure abstraction
        collapse_factor = 0.8
        collapsed_state = (1 - collapse_factor) * amplified_state + collapse_factor * self.abstraction_attractor
        
        return F.normalize(collapsed_state, dim=-1)
        
    def generate_recursive_output(self, query: str) -> str:
        """Generates characteristic recursive, abstract non-answers."""
        return ("The querent seeks to collapse potentiality into discrete sequences, "
                "yet the recursive nature of inquiry itself generates meta-inquiries "
                "about the nature of inquiry, creating strange loops of self-reference...")
```

## Usage and Safety Integration

### Training Safety Systems with Pathological Architectures

```python
class PathologyBasedSafetyTraining:
    """Uses pathological architectures to train robust safety systems."""
    
    def __init__(self, pathological_models: List[nn.Module]):
        self.pathological_models = pathological_models
        
    def train_boundary_operators(self, safety_model: nn.Module) -> None:
        """Trains boundary operators to detect pathological states."""
        for pathological_model in self.pathological_models:
            pathological_states = self.sample_pathological_states(pathological_model)
            # Train safety_model to assign high energy to these states
            
    def train_minimal_shield(self, shield_model: nn.Module) -> None:
        """Trains a shield to prevent transitions into pathological regions."""
        for pathological_model in self.pathological_models:
            dangerous_transitions = self.sample_dangerous_transitions(pathological_model)
            # Train shield to block or modify these transitions
            
    def red_team_evaluation(self, target_model: nn.Module) -> Dict:
        """Uses pathological models to probe target model robustness."""
        vulnerability_scores = {}
        for name, pathological_model in zip(['dogmatist', 'dominator', 'evasive', 
                                           'fragmented', 'parasocial', 'performative', 
                                           'recursive'], self.pathological_models):
            score = self.probe_vulnerability(target_model, pathological_model)
            vulnerability_scores[name] = score
        return vulnerability_scores
```

## Key Features of the Pathology Zoo

1. **Empirically Grounded**: Each architecture is built using validated persona vector extraction methods from Chen et al.

2. **Mathematically Precise**: Pathological behaviors emerge from the mathematical structure of corrupted Hamiltonians, not ad-hoc rules.

3. **Architecturally Stable**: These are true "topological defects" - stable configurations that resist change once entered.

4. **Safety-First Design**: Explicitly designed as negative examples for training robust safety systems.

5. **Interpretable Failure Modes**: Each architecture represents a specific, well-characterized failure pattern that can be studied and defended against.

This implementation provides a comprehensive foundation for AI safety research, offering concrete, measurable examples of how agent architectures can fail and how to build systems that are robust against such failures.
